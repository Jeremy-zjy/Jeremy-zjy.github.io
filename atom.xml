<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>右郁石</title>
  
  <subtitle>热爱生活，享受生活，分享生活</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-08-05T11:34:29.980Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>右郁石</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode309 最佳买卖股票时机含冷冻期</title>
    <link href="http://yoursite.com/2021/08/05/leetcode309/"/>
    <id>http://yoursite.com/2021/08/05/leetcode309/</id>
    <published>2021-08-05T08:15:03.000Z</published>
    <updated>2021-08-05T11:34:29.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">题目链接</a></p><p>计算最大利润（在约束条件下）：</p><ul><li>不能同时参与多笔交易（必须在再次购买前出售掉之前的股票）</li><li>卖出股票后，无法在第二天买入股票（冷冻期为一天）</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>这道题是最近遇见最难处理的一道DP题。</p><p>我们可以试想对于每一天的i，都有可能是三种状态：</p><ol><li>不持股且当天没有卖出$dp[i][0]$;</li><li>持股$dp[i][1]$;</li><li>不持股且当天卖了$dp[i][2]$;</li></ol><p>初始化：</p><p>$dp[0][0]$ = 0;</p><p>$dp[0][1]$ = -prices[0];</p><p>$dp[0][2]$ = 0;</p><p>分析：</p><p>第i天不持股且没有卖出，所以有两种可能：</p><ol><li><p>i-1天不持股且当天没有卖出</p></li><li><p>i-1天不持股但是当天卖出去了</p><p>所以： $dp[i][0]=max(dp[i-1][0],dp[i-1][2])$</p></li></ol><p>第i天持股，也有两种可能：</p><ol><li><p>昨天持股，今天继承昨天的</p></li><li><p>昨天不持股，今天买入。这里的前提是昨天一定没有卖，如果卖了则今天就无法交易了</p><p>所以：$dp[i][1]=max(dp[i-1][1],dp[i-1][0]-p[i])$</p></li></ol><p>第i天不持股且当天卖出了 == $dp[i][2]=dp[i-1][1]+p[i]$</p><p>最后一天的最大收益有两种可能，而且一定是“不持有”状态下的两种可能，把这两种“不持有”比较一下大小，返回即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int n=prices.length;</span><br><span class="line">        if(n&lt;=1) return 0;</span><br><span class="line">        int [][] dp = new int[n][3];</span><br><span class="line">        dp[0][0]=0;</span><br><span class="line">        dp[0][1]=-1*prices[0];</span><br><span class="line">        dp[0][2]=0;</span><br><span class="line">        for(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][2]);</span><br><span class="line">            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] - prices[i]);</span><br><span class="line">            dp[i][2] = dp[i-1][1]+prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[n-1][0],dp[n-1][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-st</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode279</title>
    <link href="http://yoursite.com/2021/08/03/leetcode279/"/>
    <id>http://yoursite.com/2021/08/03/leetcode279/</id>
    <published>2021-08-03T10:06:23.000Z</published>
    <updated>2021-08-03T10:06:23.850Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2021/07/22/%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2021/07/22/%E9%9A%8F%E7%AC%94/</id>
    <published>2021-07-22T13:55:17.037Z</published>
    <updated>2021-07-22T13:56:07.554Z</updated>
    
    <content type="html"><![CDATA[<p>突然回想到那份数学卷子，可能在22岁以前都没有想过，第一道第二道选择题会出错，而且恰好分数线就是388，似乎命运真的在冥冥之中和自己开了一个玩笑，不，可能不是玩笑而是命运给予你的反馈吧，毕竟一直以来的考试确实挺眷顾自己的，没有过这种致命失误，运气不好的同时也是自己没有做好万分的准备，可惜的是这次并没有眷顾自己。</p><p>可能在调剂后，心里都并没有多难受，但是现在我想这份遗憾真的可能要伴随我两年了，但是我更希望自己能做出改变，让它最好只有一年，而不是几年后的哪一天还会想起今天的遗憾，当然更想的是提升自己的能力和内涵，做自己想做的那一个优秀的自己。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;突然回想到那份数学卷子，可能在22岁以前都没有想过，第一道第二道选择题会出错，而且恰好分数线就是388，似乎命运真的在冥冥之中和自己开了一个玩笑，不，可能不是玩笑而是命运给予你的反馈吧，毕竟一直以来的考试确实挺眷顾自己的，没有过这种致命失误，运气不好的同时也是自己没有做好万</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数组与链表</title>
    <link href="http://yoursite.com/2021/07/16/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2021/07/16/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/</id>
    <published>2021-07-16T08:48:56.000Z</published>
    <updated>2021-07-16T08:59:21.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组，链表"><a href="#数组，链表" class="headerlink" title="数组，链表"></a>数组，链表</h1><p>数组：</p><p>所有元素都连续的存储于一段内存中，且每个元素占用的内存大小相同。这使得数组具备了通过下标快速访问数据的能力。<br>但连续存储的缺点也很明显，增加容量，增删元素的成本很高，时间复杂度均为 O(n)。增加数组容量需要先申请一块新的内存，然后复制原有的元素。如果需要的话，可能还要删除原先的内存。删除元素时，需要移动被删除元素之后的所有元素。</p><ul><li>优点：可以根据偏移实现快速的随机读写。</li><li>缺点：扩容，增删元素极慢。</li></ul><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-2/">参考链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组，链表&quot;&gt;&lt;a href=&quot;#数组，链表&quot; class=&quot;headerlink&quot; title=&quot;数组，链表&quot;&gt;&lt;/a&gt;数组，链表&lt;/h1&gt;&lt;p&gt;数组：&lt;/p&gt;
&lt;p&gt;所有元素都连续的存储于一段内存中，且每个元素占用的内存大小相同。这使得数组具备了通过下标快速访</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>test1</title>
    <link href="http://yoursite.com/2021/06/10/test1/"/>
    <id>http://yoursite.com/2021/06/10/test1/</id>
    <published>2021-06-10T12:39:48.000Z</published>
    <updated>2021-07-10T11:07:59.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新的一篇文章"><a href="#新的一篇文章" class="headerlink" title="新的一篇文章"></a>新的一篇文章</h1><p>友链</p><p>娱乐板块</p><p>字数统计</p><p>评论</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;新的一篇文章&quot;&gt;&lt;a href=&quot;#新的一篇文章&quot; class=&quot;headerlink&quot; title=&quot;新的一篇文章&quot;&gt;&lt;/a&gt;新的一篇文章&lt;/h1&gt;&lt;p&gt;友链&lt;/p&gt;
&lt;p&gt;娱乐板块&lt;/p&gt;
&lt;p&gt;字数统计&lt;/p&gt;
&lt;p&gt;评论&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
    <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>自动打卡</title>
    <link href="http://yoursite.com/2021/06/10/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/"/>
    <id>http://yoursite.com/2021/06/10/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/</id>
    <published>2021-06-10T12:39:48.000Z</published>
    <updated>2021-11-20T02:08:06.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="兰大自动打卡"><a href="#兰大自动打卡" class="headerlink" title="兰大自动打卡"></a>兰大自动打卡</h1><p>参考博主伍尔夫的猫的博文<a href="https://blog.csdn.net/zhaoqianchong/article/details/113060219?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163721754316780274161777%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=163721754316780274161777&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-10-113060219.first_rank_v2_pc_rank_v29&utm_term=%E7%BD%91%E9%A1%B5%E7%AB%AF%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1&spm=1018.2226.3001.4187">如何通过Python自动完成移动校园“每日健康”打卡</a>和博主CookiePie的文章<a href="https://blog.csdn.net/CookiePie/article/details/109698484">Python—利用Requests实现每日微信自动打卡</a>，拿来主义可耻，所以还是自己写一篇博客记录一下解决问题的过程，主要是为了学习，顺便激励自己好好写论文，坚持写代码，早日去实习。</p><h2 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h2><h3 id="1、抓包"><a href="#1、抓包" class="headerlink" title="1、抓包"></a>1、抓包</h3><p>不细说了，安装Fiddler或者在浏览器端的话直接用谷歌开发者工具。(我是在浏览器端完成的，小程序端会复杂些)</p><h3 id="2、安装selenium"><a href="#2、安装selenium" class="headerlink" title="2、安装selenium"></a>2、安装selenium</h3><p>我用的也是Pycharm，参考这个博主的<a href="https://blog.csdn.net/HW140701/article/details/59109649?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161140090116780261940479%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161140090116780261940479&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-59109649.first_rank_v2_pc_rank_v29&utm_term=pycharm%20webdriver.PhantomJS&spm=1018.2226.3001.4187">Python配置Selenium+Chrome环境和Selenium+PhantomJS环境</a></p><h3 id="3、配置Phantomjs"><a href="#3、配置Phantomjs" class="headerlink" title="3、配置Phantomjs"></a>3、配置Phantomjs</h3><p>如果参考上面安装过程中测试代码没有问题就可以跳过了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver = webdriver.Chrome()</span><br></pre></td></tr></table></figure><p>如果会报错，那么奖励你，继续看<a href="https://blog.csdn.net/HW140701/article/details/59109649?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161140090116780261940479%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161140090116780261940479&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-59109649.first_rank_v2_pc_rank_v29&utm_term=pycharm%20webdriver.PhantomJS&spm=1018.2226.3001.4187">Python配置Selenium+Chrome环境和Selenium+PhantomJS环境</a>，其中，第5点说明了无界面的浏览器包PhantomJS的应用。如果还会报错，可以将selenium的版本修改为了selenium2.48.0版本，亲测可以。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码参考了原博主的，然后根据学校的网站进行抓包分析，思路和原博主基本上是一致的。</p><ol><li>抓包分析</li><li>模拟登录</li><li>伪装Header发送Cookie，data</li></ol><p>但是!!!，正是由于抓取的post包里面有<strong>Authorization</strong>，</p><p><img src="/2021/06/10/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/blog_picture\daka\Snipaste_2021-11-19_21-26-02.png" alt="Snipaste_2021-11-19_21-26-02"></p><p>并且它还是刷新的，如果Header中没有授权码，则服务器默认收到的是非法数据。所以耗费了一天时间才搞定。所以重点记录解决这个问题的思路，因为我看的好几篇博客并没有遇见这个问题，只需要Cookie和User-Agent就可以了。</p><p>直接说Authorization，先读读这个<a href="https://www.cnblogs.com/wuwuyong/p/12210842.html"><a href="https://www.cnblogs.com/wuwuyong/p/12210842.html">权限认证基础:区分Authentication,Authorization以及Cookie、Session、Token </a></a>，说实话我这个菜鸡开始也不是很懂，不过看见这个，那没事了。</p><p><img src="/2021/06/10/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/blog_picture\daka\Snipaste_2021-11-19_21-11-58.png" alt="Snipaste_2021-11-19_21-11-58"></p><p>也就是说我们需要去找到服务端返回给客户端的token，也就是刷新的Authorization。所以</p><ol><li><p>找到它</p></li><li><p>获取并使用它</p></li><li><p>更新它</p><p>那么我们已经在包里面找到它了，但是实际上还是没有找到它…因为我们需要将它的值获取到且随着它更新，而不是复制出来。</p></li></ol><p>那么到这里，我当时有两个思路：</p><ol><li><p>我有一个大胆（笨比）的想法，就是webdriver.Chrome()既然是模拟浏览器操作，那么我们</p><ul><li>模拟登录后，得到新的网页</li><li>然后点击“健康打卡”又可以进入打卡界面</li><li>终于只需要点击上报就ok啦！ 这不是有手就行！？ 然后我写了如下代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">driver = webdriver.Chrome()</span><br><span class="line">    driver.maximize_window()</span><br><span class="line">    driver.get(url_)</span><br><span class="line">    driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;username&quot;]&#x27;</span>).send_keys(user_[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">    driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;password&quot;]&#x27;</span>).send_keys(user_[<span class="string">&#x27;password&#x27;</span>])</span><br><span class="line">    driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;loginForm&quot;]/div[4]/button&#x27;</span>).click()</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    cookie_ = driver.get_cookies()[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(driver.current_url)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    driver.switch_to.window(driver.window_handles[<span class="number">0</span>])</span><br><span class="line">    el = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;my-apps&quot;]/li[3]&#x27;</span>)</span><br><span class="line">    ActionChains(driver).move_to_element(el).perform()   <span class="comment">#鼠标移动到该元素停留</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    buttonElement = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;my-apps&quot;]/li[3]/a/div[2]/p[2]/span[1]&#x27;</span>)</span><br><span class="line">    ActionClick = ActionChains(driver).click(buttonElement)</span><br><span class="line">    ActionClick.perform()</span><br><span class="line">    frame1 = driver.find_element_by_id(<span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">    <span class="comment"># 切换到iframe1这个内嵌网页</span></span><br><span class="line">    driver.switch_to.frame(frame1)</span><br><span class="line">    ActionChains(driver).move_by_offset(<span class="number">843</span>, <span class="number">100</span>).click().perform()  <span class="comment"># 鼠标左键点击， 200为x坐标， 100为y坐标</span></span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">    driver.quit()</span><br><span class="line">    <span class="keyword">return</span> cookie_[<span class="string">&#x27;name&#x27;</span>] + <span class="string">&#x27;=&#x27;</span> + cookie_[<span class="string">&#x27;value&#x27;</span>]</span><br></pre></td></tr></table></figure><p>首先简简单单的就到了第二步，准备点击健康打卡，结果tmd它不是button，没办法click()，而且只有鼠标在这个模块上放一秒，它才会出现进入这个元素。所以我机智的（暴力的）通过强大的driver模拟了这一操作过程。终于，到了最后一步了，只需要点击新出现弹窗里面的“进入”就可以了，结果tmd(真的忍不住)这个弹窗就很神奇，它的元素是定位不到的！(试了很多解决方法不行)无奈之下，想到了我的老本行——暴力，把鼠标移动到这个“进入”的坐标位置点击左键即可。然后用snipaste截图测位置测了半天没找到，只能放弃。</p></li><li><p>暴力无奈之下，只能另寻他路。结果突然发现这个Authorization就是token，并且它还保存在sessionStorage里面，真的得来全不费功夫。真的需要认真读文档和博客，而不是自己瞎弄。后面就是打开切换到这个内嵌iframe上，然后获取到token值，这样就解决问题了。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cookie</span>(<span class="params">url_, user_</span>):</span></span><br><span class="line">    <span class="built_in">list</span> = []</span><br><span class="line">    driver = webdriver.Chrome()</span><br><span class="line">    driver.get(url_)</span><br><span class="line">    driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;username&quot;]&#x27;</span>).send_keys(user_[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">    driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;password&quot;]&#x27;</span>).send_keys(user_[<span class="string">&#x27;password&#x27;</span>])</span><br><span class="line">    driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;loginForm&quot;]/div[4]/button&#x27;</span>).click()</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    cookie_ = driver.get_cookies()[<span class="number">0</span>]</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    driver.switch_to.window(driver.window_handles[<span class="number">0</span>])</span><br><span class="line">    el = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;my-apps&quot;]/li[3]&#x27;</span>)</span><br><span class="line">    ActionChains(driver).move_to_element(el).perform()</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    buttonElement = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;my-apps&quot;]/li[3]/a/div[2]/p[2]/span[1]&#x27;</span>)</span><br><span class="line">    ActionClick = ActionChains(driver).click(buttonElement)</span><br><span class="line">    ActionClick.perform()</span><br><span class="line">    frame1 = driver.find_element_by_id(<span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">    <span class="comment"># 切换到iframe1这个内嵌网页</span></span><br><span class="line">    driver.switch_to.frame(frame1)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    token = driver.execute_script(<span class="string">&#x27;return sessionStorage.getItem(&quot;token&quot;);&#x27;</span>)</span><br><span class="line">    driver.quit()</span><br><span class="line">    <span class="built_in">list</span>.append(cookie_[<span class="string">&#x27;name&#x27;</span>] + <span class="string">&#x27;=&#x27;</span> + cookie_[<span class="string">&#x27;value&#x27;</span>])</span><br><span class="line">    <span class="built_in">list</span>.append(token)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line">user = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;账号&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;密码&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">list</span> = get_cookie(</span><br><span class="line">    <span class="string">&#x27;http://my.lzu.edu.cn:8080/login?service=http://my.lzu.edu.cn&#x27;</span>, user)  <span class="comment">##网页打卡入口</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Authorization&#x27;</span>: <span class="built_in">list</span>[<span class="number">1</span>],</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="built_in">list</span>[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;bh&#x27;</span>: <span class="string">&#x27;xxxxxxxxxx&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;xykh&#x27;</span>: <span class="string">&#x27;xxxxxxxx&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;twfw&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;jkm&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;sfzx&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;sfgl&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;szsf&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;szds&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;szxq&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sfcg&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;cgdd&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;gldd&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;jzyy&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;bllb&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;sfjctr&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;jcrysm&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;xgjcjlsj&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;xgjcjldd&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;xgjcjlsm&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;zcwd&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line">    <span class="string">&#x27;zwwd&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line">    <span class="string">&#x27;wswd&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line">    <span class="string">&#x27;sbr&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sjd&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;initLng&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;initLat&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dwfs&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;   <span class="comment">##= 这个就是抓取的Post包的data，更新自己的数据信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://appservice.lzu.edu.cn/dailyReportAll/api/grtbMrsb/submit&#x27;</span>  <span class="comment">##提交信息时候的php</span></span><br><span class="line">key = <span class="string">&#x27;Server酱的key&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = requests.session()</span><br><span class="line">    response = s.post(url=url, headers=headers, data=data)</span><br><span class="line">    html = response.text</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    url = <span class="string">&#x27;https://sc.ftqq.com/%s.send?text=登录页访问超时，打卡失败&#x27;</span> % key</span><br><span class="line">    requests.get(url)</span><br><span class="line"><span class="keyword">if</span> json.loads(response.text)[<span class="string">&#x27;message&#x27;</span>] == <span class="string">&#x27;成功&#x27;</span>:</span><br><span class="line">    <span class="comment">#url = &#x27;https://sc.ftqq.com/%s.send?text=自动打卡成功&#x27; % key</span></span><br><span class="line">    <span class="comment">#requests.get(url)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    url = <span class="string">&#x27;https://sc.ftqq.com/%s.send?text=自动打卡失败&#x27;</span> % key</span><br><span class="line">    requests.get(url)</span><br></pre></td></tr></table></figure><p>最后就是用<a href="https://blog.csdn.net/weixin_43229819/article/details/106398615">Windows任务计划程定时调用执行Python脚本</a></p><p>还用了<a href="https://blog.csdn.net/weixin_43745169/article/details/103792025?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163737383016780366595912%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163737383016780366595912&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-103792025.first_rank_v2_pc_rank_v29&utm_term=server%E9%85%B1&spm=1018.2226.3001.4187">Server酱</a>来提示打卡成功和打卡失败，over！</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;兰大自动打卡&quot;&gt;&lt;a href=&quot;#兰大自动打卡&quot; class=&quot;headerlink&quot; title=&quot;兰大自动打卡&quot;&gt;&lt;/a&gt;兰大自动打卡&lt;/h1&gt;&lt;p&gt;参考博主伍尔夫的猫的博文&lt;a href=&quot;https://blog.csdn.net/zhaoqiancho</summary>
      
    
    
    
    
    <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>java基础复习</title>
    <link href="http://yoursite.com/2021/06/07/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2021/06/07/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-06-07T08:12:48.000Z</published>
    <updated>2021-06-18T07:35:18.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVASE"><a href="#JAVASE" class="headerlink" title="JAVASE"></a>JAVASE</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</p><p>封装，继承，多态</p><p>类是对一类事物的描述，是抽象的、概念上的定义</p><p>对象是实际存在的该类事物的每个个体，因而也称为实例（instance）</p><p>属性=成员变量=field=域、字段</p><p>方法=成员方法=函数=method</p><p>创建类的对象=类的实例化=实例化类</p><p>局部变量没有默认初始化值</p><p>重载：</p><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p><p>可变个数形参的方法：</p><p>数据类型 …  变量名</p><p>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。</p><p>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。</p><p>可变个数形参在方法的形参中，必须声明在末尾。</p><p>可变个数形参在方法的形参中，最多只能声明一个可变形参。</p><ol start="2"><li><p>变量赋值：</p><p>基本数据类型：此时赋值的是变量所保存的数据值。</p><p>引用数据类型：此时赋值的是变量所保存的数据的地址值</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVASE&quot;&gt;&lt;a href=&quot;#JAVASE&quot; class=&quot;headerlink&quot; title=&quot;JAVASE&quot;&gt;&lt;/a&gt;JAVASE&lt;/h1&gt;&lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2021/05/27/test/"/>
    <id>http://yoursite.com/2021/05/27/test/</id>
    <published>2021-05-27T04:51:17.000Z</published>
    <updated>2021-05-28T09:18:25.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多电脑使用hexo博客"><a href="#多电脑使用hexo博客" class="headerlink" title="多电脑使用hexo博客"></a>多电脑使用hexo博客</h1><ul><li><p>【Hexo异常】fatal: in unpopulated submodule ‘.deploy_git’</p><p><a href="https://blog.csdn.net/nomasp/article/details/79504699"></a></p></li><li><h1 id="Window下完全卸载删除Nodejs"><a href="#Window下完全卸载删除Nodejs" class="headerlink" title="Window下完全卸载删除Nodejs"></a><a href="https://www.cnblogs.com/fighxp/p/7410235.html">Window下完全卸载删除Nodejs</a></h1></li><li><h1 id="nvm安装（Windows篇-https-www-jianshu-com-p-13c0b3ca7c71"><a href="#nvm安装（Windows篇-https-www-jianshu-com-p-13c0b3ca7c71" class="headerlink" title="nvm安装（Windows篇)https://www.jianshu.com/p/13c0b3ca7c71"></a>nvm安装（Windows篇)<a href="https://www.jianshu.com/p/13c0b3ca7c71">https://www.jianshu.com/p/13c0b3ca7c71</a></h1></li></ul><p>如果先安装node，再安装nvm，可能会出现修改后，版本仍然未变的情况，尝试了网上很多方法，建议还是卸载重新安装降低版本的node.js</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多电脑使用hexo博客&quot;&gt;&lt;a href=&quot;#多电脑使用hexo博客&quot; class=&quot;headerlink&quot; title=&quot;多电脑使用hexo博客&quot;&gt;&lt;/a&gt;多电脑使用hexo博客&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;【Hexo异常】fatal: in unpopul</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo+github迁移电脑</title>
    <link href="http://yoursite.com/2021/04/04/hexo-github%E8%BF%81%E7%A7%BB%E7%94%B5%E8%84%91/"/>
    <id>http://yoursite.com/2021/04/04/hexo-github%E8%BF%81%E7%A7%BB%E7%94%B5%E8%84%91/</id>
    <published>2021-04-04T13:52:33.000Z</published>
    <updated>2021-05-28T09:18:25.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo个人博客迁移"><a href="#hexo个人博客迁移" class="headerlink" title="hexo个人博客迁移"></a>hexo个人博客迁移</h1><p>从一台电脑上迁移至另外一台电脑<br> <span id="more"></span></p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul><li>复制blog文件夹</li><li>在新的电脑上下载新的git和nodejs</li><li>npm install</li><li>安装hexo,重新部署。<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-nodejs版本过高"><a href="#1-nodejs版本过高" class="headerlink" title="1.nodejs版本过高"></a>1.nodejs版本过高</h3>  下载低版本13.14。<h3 id="2-Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists-（一般是公钥出问题）"><a href="#2-Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists-（一般是公钥出问题）" class="headerlink" title="2.Please make sure you have the correct access rights and the repository exists.（一般是公钥出问题）"></a>2.Please make sure you have the correct access rights and the repository exists.（一般是公钥出问题）</h3></li></ul><ol><li><blockquote><p>git config –global user.name “你的GitHub用户名”<br>git config –global user.email “你的GitHub注册邮箱”  </p></blockquote></li><li><p>删除.ssh文件夹（直接搜索该文件夹）下的known_hosts(手动删除即可，不需要git）</p></li><li><p>生成ssh密钥文件：  </p><blockquote><p>ssh-keygen -t rsa -C “你的GitHub注册邮箱”   </p></blockquote></li><li><p>打开<a href="https://github.com/settings/keys%22">GitHub_Settings_keys</a> 页面，新建new SSH Key，把密钥复制上去。</p><h3 id="3-遇见404问题"><a href="#3-遇见404问题" class="headerlink" title="3.遇见404问题"></a>3.遇见404问题</h3><p><a href="%22https://www.jianshu.com/p/2349c763cc02?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation%22">参考解决方法</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;hexo个人博客迁移&quot;&gt;&lt;a href=&quot;#hexo个人博客迁移&quot; class=&quot;headerlink&quot; title=&quot;hexo个人博客迁移&quot;&gt;&lt;/a&gt;hexo个人博客迁移&lt;/h1&gt;&lt;p&gt;从一台电脑上迁移至另外一台电脑&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="http://yoursite.com/2020/05/05/markdown/"/>
    <id>http://yoursite.com/2020/05/05/markdown/</id>
    <published>2020-05-05T13:18:37.000Z</published>
    <updated>2021-05-28T09:18:25.762Z</updated>
    
    <content type="html"><![CDATA[<ul><li>空格<br>输入 &amp;nbsp;</li><li>空行<br>输入 &amp;emsp;</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;空格&lt;br&gt;输入 &amp;amp;nbsp;&lt;/li&gt;
&lt;li&gt;空行&lt;br&gt;输入 &amp;amp;emsp;&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>正则获取词缀集</title>
    <link href="http://yoursite.com/2020/05/05/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2020/05/05/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-05-05T12:53:43.000Z</published>
    <updated>2021-05-28T09:18:25.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从词典中获取词缀集"><a href="#从词典中获取词缀集" class="headerlink" title="从词典中获取词缀集"></a>从词典中获取词缀集</h1><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">f = open(&quot;C:/Users/张金元/Desktop/a.txt&quot;, &quot;r&quot;, encoding=&#x27;utf-8&#x27;)     #打开a.txt文件，以只读得方式，注意编码格式，含中文</span><br><span class="line">data = f.readlines()                            #循环文本中得每一行，得到得是一个列表的格式&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">f.close()                                       #关闭a.txt文件</span><br><span class="line">for line in data:</span><br><span class="line">    result = re.findall(&#x27;-(\w*\w)\s+&#x27;,line)     #使用正则表达式筛选每一行的数据,自行查找正则表达式   取得后缀</span><br><span class="line">    result1 = list(set(result))          #去掉重复后缀</span><br><span class="line">    result1.sort(key=result.index)       #按照之前的list排序</span><br><span class="line">    print(&quot;res1:%s&quot; % result1)</span><br><span class="line">for i in result1:</span><br><span class="line">    f1 = open(&quot;C:/Users/张金元/Desktop/c.txt&quot;, &quot;a+&quot;, encoding=&#x27;utf-8&#x27;)          #新建一个c.txt文本，已追加的方式写入</span><br><span class="line">    f1.write(i + &#x27;\n&#x27;)  # 将每一行打印进c.txt文件并换行</span><br><span class="line">    f1.close()  # 关闭c.txt文件**</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><h2 id="python-txt操作"><a href="#python-txt操作" class="headerlink" title="python txt操作"></a>python txt操作</h2><ul><li>打开文件：f = open(“test.txt”, ‘操作模式’)    #”test.txt”文本操作路径</li><li>w ——————————– 只能写入，如果之前有文件，则会被覆盖</li><li>r ——————————– 只能读取</li><li>a ——————————– 向文件追加</li><li>w+ ——————————– 可读可写</li><li>r+ ——————————– 可读可写</li><li>a+ ——————————– 可读可追加</li><li>wb+ ——————————写入进制文件<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3></li><li>.                    匹配任意字符（不包括换行符）</li><li>^                    匹配开始位置，多行模式下匹配每一行的开始</li><li>$                    匹配结束位置，多行模式下匹配每一行的结束</li><li>*                    匹配前一个元字符0到多次</li><li>+                    匹配前一个元字符1到多次</li><li>?                    匹配前一个元字符0到1次</li><li>{m,n}                匹配前一个元字符m到n次</li><li>\\                   转义字符，跟在其后的字符将失去作为特殊元字符的含义，例如\.只能匹配.，不能再匹配任意字符</li><li>[]                   字符集，一个字符的集合，可匹配其中任意一个字符</li><li>|                    逻辑表达式 或 ，比如 a|b 代表可匹配 a 或者 b</li><li>(…)                分组，默认为捕获，即被分组的内容可以被单独取出，默认每个分组有个索引，从 1 开始，按照”(“的顺序决定索引值</li><li>(?iLmsux)            分组中可以设置模式，iLmsux之中的每个字符代表一个模式,用法参见 模式 I</li><li>(?:…)              分组的不捕获模式，计算索引时会跳过这个分组</li><li>(?P<name>…)        分组的命名模式，取此分组中的内容时可以使用索引也可以使用name</name></li><li>(?P=name)            分组的引用模式，可在同一个正则表达式用引用前面命名过的正则</li><li>(?#…)              注释，不影响正则表达式其它部分,用法参见 模式 I</li><li>(?=…)              顺序肯定环视，表示所在位置右侧能够匹配括号内正则</li><li>(?!…)              顺序否定环视，表示所在位置右侧不能匹配括号内正则</li><li>(?&lt;=…)             逆序肯定环视，表示所在位置左侧能够匹配括号内正则</li><li>(?&lt;!…)             逆序否定环视，表示所在位置左侧不能匹配括号内正则</li><li>(?(id/name)yes|no)   若前面指定id或name的分区匹配成功则执行yes处的正则，否则执行no处的正则</li><li>\number              匹配和前面索引为number的分组捕获到的内容一样的字符串</li><li>\A                   匹配字符串开始位置，忽略多行模式</li><li>\Z                   匹配字符串结束位置，忽略多行模式</li><li>\b                   匹配位于单词开始或结束位置的空字符串</li><li>\B                   匹配不位于单词开始或结束位置的空字符串</li><li>\d                   匹配一个数字， 相当于 [0-9]</li><li>\D                   匹配非数字,相当于 [^0-9]</li><li>\s                   匹配任意空白字符， 相当于 [ \t\n\r\f\v]</li><li>\S                   匹配非空白字符，相当于 [^ \t\n\r\f\v]</li><li>\w                   匹配数字、字母、下划线中任意一个字符， 相当于 [a-zA-Z0-9_]</li><li>\W                   匹配非数字、字母、下划线中的任意字符，相当于 [^a-zA-Z0-9_]   </li></ul><p><strong><a href="https://www.cnblogs.com/dyfblog/p/5880728.html"></a></strong><br><strong><a href="https://www.cnblogs.com/a-small-Trainee/p/12825685.html"></a></strong><br>###<br><strong><a href="https://blog.csdn.net/qq_20412595/article/details/82633501">正则表达式以及group的用法</a></strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;从词典中获取词缀集&quot;&gt;&lt;a href=&quot;#从词典中获取词缀集&quot; class=&quot;headerlink&quot; title=&quot;从词典中获取词缀集&quot;&gt;&lt;/a&gt;从词典中获取词缀集&lt;/h1&gt;</summary>
    
    
    
    <category term="毕业设计" scheme="http://yoursite.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer(斐波那契数列)</title>
    <link href="http://yoursite.com/2020/02/17/%E5%89%91%E6%8C%87offer(%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91)/"/>
    <id>http://yoursite.com/2020/02/17/%E5%89%91%E6%8C%87offer(%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91)/</id>
    <published>2020-02-17T02:43:20.000Z</published>
    <updated>2021-05-28T09:18:25.763Z</updated>
    
    <content type="html"><![CDATA[<ul><li>避免递归造成的调用栈消耗<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        int b = 1;</span><br><span class="line">        while(n--&gt;0)&#123;</span><br><span class="line">            b = a + b;</span><br><span class="line">            a = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>复杂度<br>时间复杂度：O(n)O(n)<br>空间复杂度：O(1)O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;避免递归造成的调用栈消耗&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指offer(2)</title>
    <link href="http://yoursite.com/2020/01/22/%E5%89%91%E6%8C%87offer(2)/"/>
    <id>http://yoursite.com/2020/01/22/%E5%89%91%E6%8C%87offer(2)/</id>
    <published>2020-01-22T13:35:42.000Z</published>
    <updated>2021-05-28T09:18:25.760Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。  </li></ul><hr><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    String str1 = str.toString();</span><br><span class="line">        if(str1.equals(&quot;&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            return(str1);</span><br><span class="line">        &#125;</span><br><span class="line">        char [] strArray = str1.toCharArray();</span><br><span class="line">        int lengthSpace = 0;</span><br><span class="line">        for(int i = 0;i&lt;strArray.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(strArray[i]==&#x27; &#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                lengthSpace++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int newStrLength = strArray.length + lengthSpace*2;</span><br><span class="line">        char [] newstrArray = new char[newStrLength];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for(int i = 0;i&lt;strArray.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(strArray[i]!=&#x27; &#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                newstrArray[i+count*2] = strArray[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                newstrArray[i+2*count]=&#x27;%&#x27;;</span><br><span class="line">                newstrArray[i+2*count+1]=&#x27;2&#x27;;</span><br><span class="line">                newstrArray[i+2*count+2]=&#x27;0&#x27;;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        return new String(newstrArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">return str.toString().replaceAll(&quot;\\s&quot;, &quot;%20&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解：如果建新数组的话，从后往前还是从前往后都是一样的。???</p><ol><li>charAt(),deleteCharAt()   <blockquote><p>s1.charAt(3);<br> s1.deleteCharAt(3); </p></blockquote></li><li>setCharAt();<br>替换所引出的char值<blockquote><p>str.setCharAt(indexnew, ‘0’);</p></blockquote></li><li>append();  <blockquote><p>StringBuffer s1 = new StringBuffer().append(“bbb”);<br> s1.append(“aaa”);<br> System.out.println(s1.toString());</p></blockquote></li><li>replace两种用法：  <blockquote><p>replace(int start，int end, String str)<br>replace(char oldchar, char newchar)</p></blockquote></li><li>toString()  toCharArray()  <blockquote><p>StringBuffer s1 = new StringBuffer();<br>s1.toString();<br>String s2 = new String();<br>s2.toCharArray();</p></blockquote></li><li>delete(); insert(); indexOf(); lastIndexOf(); reverse(); length();<br>indexOf()返回指定字符串的开始字符索引位置，还可以从某个字符索引位置开始向后匹配，没有找到匹配的就会返回-1<br>lastIndexOf()是从后往前匹配，也支持从指定索引开始从后往前去匹配<blockquote><p>s1.delete(2,4);<br>s1.insert(2,”cc”);<br>System.out.println(s1.indexOf(“ba”));<br>System.out.println(s1.indexOf(“ba”,2));<br>System.out.println(s1.reverse());<br>System.out.println(s1.length());</p></blockquote></li><li>String,StringBuffer,StringBuilder三者的使用方法和区别<br>String适用于少量的字符串操作的情况<br>StringBuilder适用于单线程下在字符缓冲区进行大量操作的情况<br>StringBuffer适用多线程下在字符缓冲区进行大量操作的情况</li></ol><ol start="6"><li>一.java数据类型</li><li>基本数据类型<br>byte(1) boolean(1) short(2) char(2) int(4) float(4) long(8)double (8)</li><li>引用数据类型<br>string,数组，集合ArrayList,Scanner,Random,自定义类型</li><li>引用类型String中的方法<br>第一组：判断方法<br>boolean equals(String str);  //比较两个字符串是否相等<br>boolean equalsIgnoreCase(String str);  //比较两个内容是否相等 （忽略大小写）<br>boolean startsWith(String subStr); //判断某个字符串是否以指定的子串开头<br>boolean endsWith(String subStr); //判断某个字符串是否以指定的子串结尾<br>第二组：获取方法<br>int length();//获取字符串中字符个数<br>char charAt(int index); //获取字符串中某一个字符<br>String substring(int startIndex);//从指定下标开始截取字符串，直到字符串结尾<br>substring(int startIndex,int endIndex); //包括开头不包括结尾？<br>int indexof(String subStr); //获取子串第一次出现的下标<br>第三组：转换方法<br>String toLowerCase(); //转成小写串<br>String toUpperCase);  //转成大写串<br>Char[] toCharArray(); //变成字符数组<br>第四组：其他方法<br>String trim();//去掉字符串两端的空格<br>String[] split(String str); //切割字符串<br>三：读写文件<br>输出流：数据从java程序 到  文件中<br>FilWriter：文件的字符输出流，写数据  （一个字符，一个字符串，一个字符数组）<br>  write(int ch);// 写一个字符<br>  write(char[] chs); //写一个字符数组<br>  write(String s);// 写一个字符串<br>  write(char[] chs,int startInex,int len);// 写一个字符数组的一部分<br>  write(String s,int startInex,int len); //写一个字符串的一部分<br>输入流：数据从文件  到  java程序中<br>FileReader:文件的字符输入流,读数据（一个字符，一个字符数组）<br>   int read();//读取一个字符  ASCII<br>   int read(char[] chs); //一次读取一个字符数组，返回值是读取的字符的个数<br>文件的路径分为两种：</li><li>相对路径：<pre><code>  相对于当前项目而言的</code></pre></li><li>绝对路径：<pre><code>  以盘符开头</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习1</title>
    <link href="http://yoursite.com/2020/01/04/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2020/01/04/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</id>
    <published>2020-01-04T03:20:24.000Z</published>
    <updated>2021-05-28T09:18:25.759Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>类的概念：<br> 一堆具有共同的成员变量、属性和成员方法、功能对象集合</p></li><li><p>接口的概念：<br> 接口是功能的集合，就是方法的集合<br> 也就是说 接口中只能定义方法，不能定义普通的成员变量<br> 而且接口中的成员方法，必须都是抽象的<br> 接口是比抽象类还要抽象的一种类型</p><span id="more"></span><p> 问题：接口能创建对象吗？不能</p><pre><code> 接口作用：天生作为“父接口”</code></pre></li><li><p>接口的定义：<br> 定义接口用关键字：interface<br> 定义枚举用关键字：enum</p><p> 格式：<br> public interface 接口名字{</p><pre><code> //成员变量，不能定义普通的成员变量 //成员方法：必须都是抽象 public abstract 返回值类型 方法名();</code></pre><p> }</p><p> 类和接口的本质区别不大，他们的源码都是.java文件<br> 编译后都是.class文件</p></li><li><p>类与类之间：继承，而且是单继承，一个子类，只能有一个直接父类<br> 接口和接口之间:继承，但是可以多继承，一个子接口 可以有多个直接父接口</p><p> 面试题：Java到底支不支持多继承？</p><pre><code> 如果是类与类  不支持多继承  只支持多层继承 如果是接口和接口  支持多继承  也支持多层继承</code></pre><p> 类和接口之间：不叫继承(extends),叫实现(implements),可以多实现</p><pre><code> 只有类 实现接口</code></pre></li><li><p>接口中成员的特点<br> 5.1成员变量，但是必须有固定修饰符public static final 数据类型 变量 = 值<br> 5.2成员方法，必须是固定修饰符public abstract 即抽象方法<br> 5.3接口不可以创建对象(抽象类也是)<br> 5.4实现类 实现类接口，那么必须重写接口中所有的抽象方法，然后才能创建对象</p><pre><code> 否则 这个实现类 还是一个抽象类，是不能创建对象的 在开发中最常用的模式：     public class A extends AbstractClassB implements 接口A，接口B&#123;         注意：         A中必须重写 抽象类中的抽象方法，以及所有接口中的抽象方法     &#125; </code></pre></li><li><p>接口和抽象类的异同：</p></li><li><p>相同点：<br>  a.都不能创建对象<br>  b.都是作为父类/父接口<br>  c.子类/实现类 都必须重写抽象方法，然后才能创建对象</p></li><li><p>不同点：<br>  a.抽象类用关键字abstract  接口用关键字interface<br>  b.接口中只要有方法，必须都是抽象的<br>  c.抽象类可以定义任意成员变量  接口的成员变量必须public static final修饰<br>  d.类和抽象类之间关系是单继承，类和接口之间关系是多实现<br>  e.思想上的区别<br>  1.抽象类中必须定义整个继承体系中的共性内容<br>  2.接口中定义 整个继承体系之外的 额外扩展的功能。</p></li></ol><p>7.面向对象3大特征：封装(安全性)，继承(扩展性)，多态(灵活性)<br>    多态：<br>    前提1.必须有子父类关系<br>        2.必须有方法的重写<br>    多态在Java中的表现形式：<br>        父类类型  变量名 = new 子类类型();<br>        接口类型  变量名 = new 实现类();<br>        Animal an = new Cat();<br>        父类类型的变量指向了子类的对象<br>    注意：<br>        1.使用多态调用成员变量<br>            编译时，看父类<br>            运行时，看父类<br>        2.使用多态调用成员方法<br>            编译时，看父类<br>            运行时，看子类<br>总结：<br>    弊端：多态只能调用子父类共有的方法，不能调用子类特有的方法<br>    好处：提高灵活性<br>    父类类型的变量，可以接收任何一个子类的对象<br>    调用方法的时候，编译是看父类，运行时运行的传递过来的子类对象的方法<br>    弊端的解决方案：<br>        向下转型：强制类型转换<br>        向上转型：自动类型转换 (就是多态)<br>    向下转型也有弊端：<br>        把父类的变量 转成任何子类类型时候，编译器直接通过<br>        可以转成cat,本质是dog 所以出错<br>    Java中解决向下转型弊端的方法：<br>        一个关键字Instanceof 运算符<br>        作用：判断某一个变量 不是 该类的类型<br>        格式：<br>            boolean b = an instanceof 类名<br>    多态提高程序的灵活性，扩展性，复用性。</p><ol start="7"><li><p>static的介绍:<br> static的作用用来修饰类中的成员<br> 1.如果一个类的成员被static修饰了，怎么访问？ 类名.成员变量名<br> 存在方法区中的静态区，只有一个空间  优先于对象存在<br> 2.类名.成员变量(推荐)   对象.成员变量   都可以<br> 3.所有对象共有的，被staic修饰的成员属于类，不属于单个对象<br> 4.静态没有多态性 静态不属于对象，属于类<br> 5.静态代码块：</p><pre><code> 在类的成员位置     static&#123;         代码     &#125;</code></pre><p> 特点：<br> 使用到这个类时，JVM会自动执行静态代码块<br> 只会第一次使用时执行<br> 优先级比构造方法高，比main方法高<br> 作用：用来初始化类的,myswl数据(静态代码块来加载驱动)</p></li><li><p>final可以修饰<br> 类，成员变量，成员方法，局部变量(基本类型，引用类型)<br> 1.修饰类(太监类)，不能被继承<br> 2.final修饰成员变量: </p><pre><code> 2.1必须在创建对象之前有却确定的值 2.3只能赋值一次</code></pre><p> 3.修饰方法:</p><pre><code> 不能被子类重写</code></pre><p> 4.修饰基本类型局部变量</p><pre><code> 被final修饰的基本类型局部变量  只能赋值一次</code></pre><p> 5.修饰引用类型局部变量</p><pre><code> 被final修饰的引用类型局部变量  只能赋值一次 但是引用类型所指向的对象中内容是可以改变的</code></pre></li><li><p>匿名内部类：是一种特殊的语法，用来快速创建抽象类的子类对象</p><pre><code>         用来快速创建 接口的实现类对象</code></pre><p> AbstractAnimal an1 = new AbstractAnimal(){</p><pre><code> 重写</code></pre><p> }<br> 多态</p></li><li><p>引用数据类型<br>a.类作为方法的参数或者返回值(我们需要传递或返回的是该类的对象)<br>b.抽象类作为方法的参数和返回值  (和9结合起来)我们需要传递或返回的是该抽象类的子类的对象<br>c.接口作为方法的参数和返回值   (我们需要传递或返回的是该接口的实现类的对象)</p></li><li><p>链式编程</p></li><li><p>权限修饰符<br>如果一个成员只想在本类中使用 用private修饰<br>如果一个成员想在本类和本包的其它类中使用 不写 default<br>如果一个成员想在本类，本包，其他包的子类中使用 用protected修饰<br>如果一个成员想在所有类中使用 用public修饰</p></li><li><p>Object类：<br>类Object是类层次结构的根类<br>所有类都必须直接或者间接的继承object</p><ol><li>boolean equals(Object obj);<br>p1.equals(p2);<br>//比较两个对象是否相等,在Object类中定义equals方法比较是 两个对象的地址<br>在String类中 重写了object父类中的equals方法，<br> 本来在object类中比较的是两个对象的地址<br> 在String重写后变成比较两个字符串的内容</li></ol><p>我们程序员 通常自定义一个类 也会重写equals</p><ol start="2"><li>toString(); //返回该对象的字符串表示<br> Object类中的默认的返回值：包名.类名@地址<br> 实际开发中toString的使用，重写toString 返回对象中的成员变量</li></ol></li><li><p>异常:是java代码编译或者运行过程中<br>异常的继承体系:<br>Throwable(异常和错误的超类):可以抛出去的东西</p><pre><code>--Exception:异常(普通问题) --编译时异常:  指的是Exception 以及Exception子类  (除了RuntimeException)--运行时异常:  RuntimeException以及其子类--Error:错误(严重问题) 比如:OutOfMemoryError:超出内存错误如果程序出现了错误，只能改代码</code></pre><p>创建异常对象，对异常的基本操作：<br>1.抛出异常 2.处理异常(捕获异常，将异常获取，使用try/catch做分支处理)<br>JVM默认处理异常的方式:(中断处理)<br>处理异常的方式：<br>1.不处理</p><pre><code>public 返回值类型 方法名(参数)throws xxxException&#123;&#125;</code></pre><p>2.捕获处理</p><pre><code>try&#123;    可能出现的异常的代码&#125;catch(Exception e)&#123;    //处理异常&#125;finally&#123;    //写上必须要执行的代码    //释放资源的代码&#125;</code></pre><p>3.其他的处理方式</p><pre><code>多个异常分别处理多个个异常一次捕获多次处理多个异常一次捕获一次处理</code></pre><p>父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理。<br>打印异常信息:printStackTrace<br>1.RuntimeException<br>2.ClassCastException   类型转换异常(向下转型的时候)<br>3.ArrayIndexOutOfBoundsException  数组下标越界<br>4.StringIndexOutOfBoundsException  字符串下标越界<br>自定义异常类：<br>1.创建一个类，这个类必须用Exception结尾<br>2.必须继承Exception 或者  RumtimeException<br>3.自定义的异常 至少有两个构造</p><pre><code>a.空参数构造b.带有String类型参数构造</code></pre></li><li><p>Object类:是所有类的根类<br>boolean equals(Object obj)<br>a.Object类中equals方法,比较是两个对象的地址，就是==号的作用<br>b.重写  比较两个字符串的内容   比较两个对象的成员变量的值<br>String toString();//返回该对象的字符串表示   hashCode()返回该对象的数字表示</p></li><li><p>什么叫设计模式？<br>把解决问题的方案 总结出一个套路</p></li><li><p>代理设计模式<br>  1.1静态代理设计模式<br>  1.2动态代理设计模式</p></li><li><p>date类:日期类</p><pre><code>表示特定的瞬间，精确到毫秒</code></pre><p>public Date(); //无参构造<br>public Date(long time);<br>1.DateFormat是一个抽象类 我们不能用它<br>2.我们使用它的一个子类：SimpleDateFormat<br>SimpleDateFormat:简单的日期格式化类<br>1.构造</p><pre><code>public SimpleDateFormat(String pattern);//以指定的模式 创建一个日期格式化对象</code></pre><p>2.成员方法</p><pre><code>public String format(Date d);//格式化一个日期对象，返回格式化后的一个字符串public Date parse(String s);//把一个字符串形式的日期，解析成Date对象</code></pre></li><li><p>Calender类<br>获取Calendar的子类对象<br>获取Calender对象的某个字段 (get)</p></li><li><p>System类<br>它不能被实例化，因为构造方法私有化了<br>而且System类中的方法都是静态的，通过类名就可以直接访问<br>System.exit(0); //退出JVM<br>public static void gc(); //运行java的垃圾回收器(并不是马上运行)<br>public static String getProperty(String ProertyName);//获取某一个属性的值<br>public static long currentTimeMillis();//获取当前系统的毫秒值</p></li><li><p>String(不可变)  StringBuilder(可变)<br>//当出现大量的字符串拼接运算 时 用StringBuilder</p></li><li><p>基本数据类型 对应的引用类型<br>int Integer<br>拆箱：包装类型—&gt;基本类型<br>装箱：基本类型—&gt;包装类型</p></li><li><p>正则表达式：</p></li><li></li><li><p>javac 生成编译文件</p></li><li><p>java 执行类文件，出错原因java程序运行class文件,对于有包名的类,java把包名当成文件夹处理.”包名+类名”相当于”文件夹目录+类名”来寻找类。</p></li><li><p>b = a++ a先赋值，再自增。  </p></li><li><p>mysql Orcale DB2(银行系统)  SQLite(手机端) SQLServer SyBase(建模工具PowerDesigner) </p></li></ol>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;类的概念：&lt;br&gt; 一堆具有共同的成员变量、属性和成员方法、功能对象集合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接口的概念：&lt;br&gt; 接口是功能的集合，就是方法的集合&lt;br&gt; 也就是说 接口中只能定义方法，不能定义普通的成员变量&lt;br&gt; 而且接口中的成员方法，必须都是抽象的&lt;br&gt; 接口是比抽象类还要抽象的一种类型&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>考研</title>
    <link href="http://yoursite.com/2019/03/24/%E8%80%83%E7%A0%94/"/>
    <id>http://yoursite.com/2019/03/24/%E8%80%83%E7%A0%94/</id>
    <published>2019-03-24T02:09:24.000Z</published>
    <updated>2021-05-28T09:18:25.765Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><pre><code>失败不是终点，找好工作再说8</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;pre&gt;&lt;code&gt;失败不是终点，找好工作再说8
&lt;/code&gt;&lt;/pre&gt;
</summary>
      
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言</title>
    <link href="http://yoursite.com/2019/02/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2019/02/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</id>
    <published>2019-02-25T03:00:32.000Z</published>
    <updated>2021-05-28T09:18:25.764Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="数据寻址方式"><a href="#数据寻址方式" class="headerlink" title="数据寻址方式:"></a>数据寻址方式:</h3><ul><li>CPU:</li></ul><ol><li>立即寻址方式</li><li>寄存器寻址方式</li></ol><ul><li>存储器：</li></ul><ol><li>直接寻址方式</li><li>间接寻址方式</li><li>相对寻址方式</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;指令系统&quot;&gt;&lt;a href=&quot;#指令系统&quot; class=&quot;headerlink&quot; title=&quot;指令系统&quot;&gt;&lt;/a&gt;指令系统&lt;/h2&gt;&lt;h3 id=&quot;数据寻址方式&quot;&gt;&lt;a href=&quot;#数据寻址方式&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记2</title>
    <link href="http://yoursite.com/2019/02/11/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <id>http://yoursite.com/2019/02/11/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</id>
    <published>2019-02-11T02:35:11.000Z</published>
    <updated>2021-05-28T09:18:25.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="io-多线程-网络编程-XML"><a href="#io-多线程-网络编程-XML" class="headerlink" title="io 多线程  网络编程  XML"></a>io 多线程  网络编程  XML</h2><span id="more"></span><ul><li><p>IO流<br>  1.字符流,字节流<br>  字符输入流：共同的父类Reader  比如FileReader,BufferedReader</p><pre><code>  功能：读取一个字符，读取一个字符数组(一部分)，读取一个字符串</code></pre><p>  字符输出流：共同的父类Writer  比如FileWriter,BufferedWriter</p><pre><code>  功能：写一个字符，写一个字符数组(一部分)，写一个字符串</code></pre><p>  字节输入流：共同父类 InputStream  比如：FileInputStream,BufferInputStream    读取一个字节   读取一个字节数组<br>  字节输出流：共同父类 OutputStream  比如：FileOutputStream,BufferOutputStream    写一个字节   写一个字节数组<br>  2.OutputStream:字节输出流的根类，这是一个抽象类<br>  public void close();<br>  public void flush(); //刷新流<br>  public void write(int b); //写一个字节<br>  public void write(byte[] bs); //写一个字节数组<br>  public void writre(byte[] bs,int startIndex, int lenght);//写一个字节数组的一部分<br>  3.续写和换行<br>  FileOutputStream fos = new FileOutputStream(“2.txt”,true);<br>  fos.write(“\r\nhello”.getBytes());<br>  fos.close();<br>  4.InputStream:字节输入流的根类，这是一个抽象类<br>  1.public int read();、、读取一个字节，返回是码值<br>  2.public int read(byte[] bs);//读取一个字节数组，返回值表示实际读取到的字节数<br>  我们用InputStream具体子类：FileInputStream<br>  一次读取一个字节<br>  FileIntputStream fis = new FileIntputStream(new File(“1.txt”));<br>  int b = 0;<br>  while(b=fis.read()!=-1)<br>  {</p><pre><code>  System.out.println((char)b);</code></pre><p>  }<br>  fis.close();<br>  一次读取一个字节数组<br>  byte[] bs = new byte[4];<br>  int len = fis.read(bs);<br>  System.out.println(len); //实际字节数<br>  System.out.println(new String(bs));<br>  标准：<br>  while((len = fis.read(bs)!=-1))<br>  {</p><pre><code>  System.out.println(new String(bs,0,len))</code></pre><p>  }<br>  复制文件：<br>  long s= System.currentTimeMillis(); //系统时间<br>  while((len = fis.read(bs)!=-1))<br>  {</p><pre><code>  fos.writ(bs,0,len);</code></pre><p>  }<br>  字节缓冲流：<br>  BufferedOutputStream bos = new BufferedOutputStream(new FileOutputaStream(“1.txt”));<br>  字节流读取中文的乱码问题：读取中文读了一半<br>  解决问题：字符流  转化流<br>  字符编码表(字符集)<br>  ASCII码表<br>  在GBK码表中一个中文2个字节 在UTF-8中一个中文 3个字节<br>  OutputStreamWriter  是字符流通向字节流的桥梁，查码表(编码)<br>  OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(“1.txt”));<br>  osw.close();<br>  字节-&gt;解码-&gt;字符： InputStreamReader<br>  字符-&gt;编码-&gt;字节： OutputStreamWriter<br>  transient关键字：<br>  用来修饰成员变量 用不用没有影响<br>  序列化的时候有用，如果一个成员变量被transient修饰，那么序列化的时候会忽略该成员变量<br>  static:关键字 他也具有和transient一样的功能<br>  打印流：<br>  PrintWriter:打印字符流<br>  PrintyStream:打印字节流</p><p>  使用第三方框架的步骤<br>  1.导入classpath<br>  a.在工程根目录下 建立一个目录”lib”<br>  b.把要使用的第三方框架的jar包拷贝过来<br>  c.添加构建路径 右键单击jar包—-&gt;Build Path —-&gt; Add to Build Path<br>  以FileUtils为例</p></li><li><p>多线程</p><ol><li>内存RAM  硬盘ROM<br>多线程程序并不能提高程序的运行速度，但能够提高程序运行速率，让cpu的使用率更高。<br>main方法所在线程  我们就称为主线程<br>Thread类：线程类<br>public Thread();//创建一个默认名字的线程对象<br>public Thread(String name);//创建一个指定名字的线程对象<br>第一种：继承<br>class 子线程类 extends Thread{<br> run(){<pre><code> 任务代码</code></pre> }<br>}<br>子线程类 t = new 子线程类();<br>t.start();<br>第二种：声明实现Runable接口的类，重写run方法，创建实现类对象，创建Thread对象，并把刚刚的实现类对象 作为参数传递，启动这个Thread对象<br>从耦合性分析用第二种<br>扩展性:第一种继承Thread，那么子线程类就不能继承别的类<br>第二种方式  由于是实现了接口，同时可以继承别的类<br>匿名内部类创建线程对象</li><li>new Thread(){<br> public void run(){<pre><code> /////////</code></pre> }<br>}.start();</li><li>new Thread(new Runnable(){<br> public void run(){<pre><code> /////</code></pre> }<br>}).start();<br>线程安全问题：1.同步锁  synchronized(obj)</li><li>同步方法:<br>public synchronized void sale()<br>{<br>}<br>这里同步方法使用的锁对象  叫做this对象<br>这里同步方法是静态方法，那么他的锁对象是当前类.class</li><li>lock接口方式<br>实现类：ReentrantLock</li></ol></li><li><p>网络编程  udp  tcp<br>  InetAddress</p></li><li><p>XML语法<br>  文档说明：</p>  <?xml version="1.0 encoding="TTF-8"?><p>  作用：存放数据  配置文件<br>  CDATA区 <!--[CDATA[]]--></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;io-多线程-网络编程-XML&quot;&gt;&lt;a href=&quot;#io-多线程-网络编程-XML&quot; class=&quot;headerlink&quot; title=&quot;io 多线程  网络编程  XML&quot;&gt;&lt;/a&gt;io 多线程  网络编程  XML&lt;/h2&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫初学</title>
    <link href="http://yoursite.com/2019/02/09/python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/"/>
    <id>http://yoursite.com/2019/02/09/python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/</id>
    <published>2019-02-09T09:44:38.000Z</published>
    <updated>2021-05-28T09:18:25.762Z</updated>
    
    <content type="html"><![CDATA[<p>#coding:utf-8</p><span id="more"></span><p>#author:Ericam_</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import urllib.request</span><br><span class="line">import time</span><br><span class="line">headers = (&#x27;User-Agent&#x27;, &#x27;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&#x27;)</span><br><span class="line">opener = urllib.request.build_opener()</span><br><span class="line">opener.addheaders = &#123;headers&#125;</span><br><span class="line">urllib.request.install_opener(opener)</span><br><span class="line">def get_download(url):</span><br><span class="line">    file = urllib.request.urlopen(url)</span><br><span class="line">    data = BeautifulSoup(file , from_encoding=&quot;utf8&quot;)    </span><br><span class="line">    section_name = data.title.string</span><br><span class="line">    print(section_name)</span><br><span class="line">    section_text = data.select(&#x27;#content #left font&#x27;)[0].text</span><br><span class="line">    section_text=re.sub( &#x27;\s+&#x27;, &#x27;\r\n\t&#x27;, section_text).strip(&#x27;\r\n&#x27;)</span><br><span class="line">    fp = open(&quot;D:/python/2.txt&quot;,&#x27;a&#x27;,encoding=&#x27;utf-8&#x27;)   </span><br><span class="line">    fp.write(section_name+&#x27;\n&#x27;)  </span><br><span class="line">    fp.write(section_text+&#x27;\n&#x27;)  </span><br><span class="line">    fp.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    url = &quot;http://www.net767.com/shuji/fubaba/10995.html&quot;</span><br><span class="line">    while(True):</span><br><span class="line">        file = urllib.request.urlopen(url)</span><br><span class="line">        data = BeautifulSoup(file , from_encoding=&quot;utf8&quot;)    </span><br><span class="line">        section_name = data.title.string</span><br><span class="line">        print(section_name)</span><br><span class="line">        section_text = data.select(&#x27;#content #left font&#x27;)[0].text</span><br><span class="line">        section_text=re.sub( &#x27;\s+&#x27;, &#x27;\r\n\t&#x27;, section_text).strip(&#x27;\r\n&#x27;)</span><br><span class="line">        print(section_text)</span><br><span class="line">        txt_section=data.select(&#x27;#pagebar a&#x27;)</span><br><span class="line">        l1=len(txt_section)</span><br><span class="line">        for num in range(1,l1-1):</span><br><span class="line">            y=txt_section[num][&#x27;href&#x27;]</span><br><span class="line">            url = &quot;http://www.net767.com&quot;+y</span><br><span class="line">            get_download(url)</span><br><span class="line">            print(y)</span><br><span class="line">        txt2_section=data.select(&#x27;.LinkNextArticle&#x27;)</span><br><span class="line">        y2=txt2_section[0][&#x27;href&#x27;]</span><br><span class="line">        url = &quot;http://www.net767.com&quot;+y2</span><br><span class="line">        if(url == &#x27;http://www.net767.com/shuji/fubaba/11003_9.html&#x27;):</span><br><span class="line">            break</span><br><span class="line">        print(y2)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;#coding:utf-8&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记2</title>
    <link href="http://yoursite.com/2019/02/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://yoursite.com/2019/02/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</id>
    <published>2019-02-08T00:35:42.000Z</published>
    <updated>2021-05-28T09:18:25.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目（秒杀系统）"><a href="#项目（秒杀系统）" class="headerlink" title="项目（秒杀系统）"></a>项目（秒杀系统）</h1><span id="more"></span><ul><li><p>集合(collection)：<br>  数组的长度是固定的，集合的长度是可变的。<br>  每一个容器的数据结构不一样<br>  Collection接口定义着集合框架中最最共性的内容<br>  size(); add(); remove(); clear(); contains(); toArray();<br>  集合的遍历：<br>  在根接口中使用了一种公共的遍历方式，迭代器遍历</p><ol><li>获取一个集合的迭代器对象(迭代器对象不是我们创建的，而是每个集合自带的) 是一个接口<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = names.iterator();</span><br><span class="line">while(it.hasnext())&#123;</span><br><span class="line">    String s = it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>java规定，如果一个集合使用迭代器遍历，那么遍历的过程中，不允许修改集合长度</li><li>增强for循环<br>Collection<String> names = new ArrayList<String>();<br>for(数据类型 变量名：数组/集合){<br> syso(变量名);<br>}<br>使用增强for循环遍历集合的时候，不能修改集合的长度</String></String></li><li>泛型:E实际上是一个“变量”  用来保存一种数据类型<br> <E>,&lt;K,V&gt;<br> 可以用在类，方法，接口上。<br> 泛型通配符<br> ？：代表任意类型</E></li><li>Collections.shuffle(cards); //洗牌</li><li>栈，队列<br>数组结构  Arraylist   Vector   查询快，增删慢<br>链表结构：一般使用双向链表<br>哈希表结构：查询快 增删快</li><li>List接口特点：有下标，有序的，可重复<br>实现类：ArrayList,LinkedList,Vector 安全<br>List结构中的方法：<br>增：add(E e);  add(int index,E e)<br>删：remove(Object obj);remove(int index);<br>改：set(int index,E e);<br>查：get(int index);<br>其他：<br> size();clear(),contains(Object obj),toArray();<br> iterator();isEmpty();</li><li>ArrayList:方法基本和List一致  </li><li>LinkedList:还有大量的首尾操作方法<br>void addFirst(E e);<br>E removeFirst();<br>E getFirst();<br>E pop();  和removeFirst一致<br>void push(E e);   推入  和addFirst一致</li><li>Set接口<br>a.无下标<br>b.无序的<br>c.不可重复<br>实现类：<br>HashSet：底层采用哈希表结构，查询快，增删快，无序的<br>LinkedHashSet:链表＋哈希表，查询快，增删快，有序<br>Set接口中的特有方法和Collection基本一致<br>TreeSet:红黑树</li><li>哈希表<br>哈希值：每一个对象都具有哈希值<br>地址值实际是哈希值的16进制<br>String对象的哈希值：重写了Object类中的hashCode<br>不再通过地址值计算 只和字符串内容相关<br>哈希表结构，添加元素判断是否重复</li><li>先判断新旧元素的哈希值</li><li>再判断新旧元素的equals<br>自定义类，要使用HashSet存储<br>保证元素唯一性：<br>  必须重写自定义类的两个方法  hashcode   equals<br>定义一个标准得类：</li><li>封装</li><li>构造</li><li>toString</li><li>hashCode equals<br>contains方法：<br>ArrayList:names.contains(“abc”);<br>HashSet:set.contains(“abc”);</li><li>Map接口<br>Map&lt;K,V&gt;集合常用方法： 、<br>HashMap<br>增：put(K key,V value);  //向集合中添加键值对<br>//如果集合中已存在该键，覆盖整个键值对，并返回被覆盖的键值对的值<br>判断k是不是空<br>哈希表结构，添加元素判断是否重复</li><li>先判断新旧元素的哈希值</li><li>再判断新旧元素的equals<br>删：v remove(object key);  //返回被删除的键值对的值<br>改：==put<br>查：V get(K key);  判断是不是空<br>Map集合遍历：   LinkedHashMap   HashMap<br>getKey();<br>getValue();</li><li>keySet遍历<br>Set<Student> keys = students.keySet();  //放在set集合中<br>map.KeySet(); Iterator  hasnext<br>for(String key : keys)<br>{<br>  String value = students.get(key);<br>}</Student></li><li>Set&lt;Map.Entry<String string="">&gt; entrySet = map.entrySet();<br>Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = entrySet.iterator();<br>while(it.hasNext(){<br>  Map.Entry&lt;String, String&gt; entry = it.next();<br>  String key = entry.getKey();<br>  String value = entry.getValue();<br>  system.out.println(key+”=”+value)；<br>})<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Set;</span><br><span class="line">  </span><br><span class="line">public class MapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        //map集合存入数据</span><br><span class="line">        map.put(1, &quot;第一个value&quot;);</span><br><span class="line">        map.put(2, &quot;第二个value&quot;);</span><br><span class="line">        map.put(3, &quot;第三个value&quot;);</span><br><span class="line">         </span><br><span class="line">        //通过keySet取出map数据[for-each循环]</span><br><span class="line">        System.out.println(&quot;-------[for-each循环遍历]通过keySet取出map数据-------&quot;);</span><br><span class="line">        Set&lt;Integer&gt; keys = map.keySet();  //此行可省略，直接将map.keySet()写在for-each循环的条件中</span><br><span class="line">        for(Integer key:keys)&#123;</span><br><span class="line">            System.out.println(&quot;key值：&quot;+key+&quot; value值：&quot;+map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //通过EntrySet取出map数据[for-each循环]</span><br><span class="line">        System.out.println(&quot;-------[for-each循环遍历]通过EntrySet取出map数据-------&quot;);</span><br><span class="line">        Set&lt;Entry&lt;Integer, String&gt;&gt; entrys = map.entrySet(); //此行可省略，直接将map.entrySet()写在for-each循环的条件中</span><br><span class="line">        for(Entry&lt;Integer, String&gt; entry:entrys)&#123;</span><br><span class="line">            System.out.println(&quot;key值：&quot;+entry.getKey()+&quot; value值：&quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //通过keySet取出map数据[Iterator遍历]</span><br><span class="line">        System.out.println(&quot;-------[Iterator循环遍历]通过keySet取出map数据---------&quot;);</span><br><span class="line">        Iterator&lt;Integer&gt; it = map.keySet().iterator(); //map.keySet()得到的是set集合，可以使用迭代器遍历</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">            Integer key = it.next();</span><br><span class="line">            System.out.println(&quot;key值：&quot;+key+&quot; value值：&quot;+map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //通过EntrySet取出map数据[Iterator遍历]</span><br><span class="line">        System.out.println(&quot;-------[Iterator循环遍历]通过EntrySet取出map数据---------&quot;);          </span><br><span class="line">        Iterator&lt;Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator(); //map.entrySet()得到的是set集合，可以使用迭代器遍历</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(&quot;key值：&quot;+entry.getKey()+&quot; value值：&quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>内部类：<br>OutClass.InterClass ic = new OutClass.new InterClass();<br>内部接口    实现谁，重写谁<br>如果Map中的键是自定义类型，那么要保证键的唯一性，必须重写键对应类的hashCode和equals方法</String></li><li>Properties类<br>本质就是一个Map集合<br>持久的属性集<br>ps.store(new FileWriter(“phones.properties”),””);//存<br>ps.load(new FileReader(“phones.properties)); //读取<br>没有泛型<br>具有Map接口的一切方法，以及自己特有的<br>getProperty();<br>setProperty();<br>public Set<String> stringPropertyNames();//和KeySet一样<br>Properties ps = new Properties();<br>可变参数：<br>public static int add(int…a){<br>  return 0;<br>}<br>//类型不能改变，多个参数时，可变参数在最后面<br>本质：数组  for(int i : a)<br>Collections：(集合工具类)中的静态方法：<br>public static void shuffle(List list);//打乱顺序<br>public static void sort(List list);//把集合元素按照自然顺序排序<br>Arrays:数组工具类<br>public static List asList(数组/可变参数); //把数组转化为List集合<br>Arrays.sort(nums);<br>Arrays.toString(nums);<br>Map集合的嵌套：</String></li></ol></li><li><p>File类</p><ol><li>File类可以表示文件  也可以表示文件夹<br>构造：<br> 1.public File(String filepath);<br> 绝对路径：以盘符开头的路径<br> 相对路径：相对当前项目的根目录<br> 2.public File(String parent ,String child);<br> 3.public File(File parent,String child);</li><li>File对象的获取方法<br>public String getAbsolutePath();//获取绝对路径<br>getName();  getPath();<br>public long length(); //获取File对象(文件)的字节数  不能计算文件夹</li><li>File对象的删除和创建方法：</li><li>创建方法<br>  创建文件：<pre><code>  public boolean creatNewFile(); //创建新的文件</code></pre>  创建文件夹<pre><code>  public boolean mkdir();</code></pre></li><li>判断方法<br>  判断是否是文件<pre><code>  public boolean isFile();</code></pre>  判断是否是文件夹<pre><code>  public boolean isDirectory();</code></pre>  判断是否存在<pre><code>  public boolean exists();</code></pre></li><li>删除<pre><code>  public boolean delete();</code></pre></li><li>File类下的list和listFiles方法(文件夹)<br>  1.public String[] list();<br>  2.public File[] listFiles();<br>  只能列出当前文件下的一级子文件或者子文件夹<br>  扩展：删除先删文件再删文件夹</li><li>递归打印目录下的所有文件</li><li>文件过滤器：FileFilter<br>在list和listFiles方法中使用</li></ol></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;项目（秒杀系统）&quot;&gt;&lt;a href=&quot;#项目（秒杀系统）&quot; class=&quot;headerlink&quot; title=&quot;项目（秒杀系统）&quot;&gt;&lt;/a&gt;项目（秒杀系统）&lt;/h1&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>javascript学习笔记</title>
    <link href="http://yoursite.com/2019/01/21/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/01/21/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-01-21T08:28:38.000Z</published>
    <updated>2021-05-28T09:18:25.761Z</updated>
    
    <content type="html"><![CDATA[<p>参考菜鸟教程进行学习<br>  <span id="more"></span></p><h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><p>HTML 中的脚本必须位于 <script> 与 </script> 标签之间。脚本可被放置在 HTML 页面的 <body> 和 <head> 部分中，也可以保存在外部文件中（则不需要加标签）。</head></body></p><h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><ul><li>使用 window.alert() 弹出警告框。</li><li>使用 document.write() 方法将内容写到 HTML 文档中。</li><li>使用 innerHTML 写入到 HTML 元素。</li><li>使用 console.log() 写入到浏览器的控制台。  </li></ul><script>    var y;    var z;    var d;x=document.getElementsByClassName("Barrage-listItem");y=document.getElementById(x[0].id);d=y.getElementsByTagName("div");var reg = /Barrage-userEnter/i;    console.log(reg.test(d[0].className)); console.log(d[0].className);if(reg.test(d[0].className)){z=y.getElementsByTagName("span");console.log(z[2].title);d[0].className="b";}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考菜鸟教程进行学习&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
