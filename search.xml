<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo+github搭建博客</title>
    <url>/2019/01/19/hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>  搭建博客的过程教程很多，我也是参照网上的教程搭建的博客。搭建博客已经过去半年了，但是自己这么久却没有写这篇博文，多说无益，希望能从这篇博客开始先记录hexo博客的问题以及解决方法然后能坚持下去将自己所学所见记录下来，也作为自己生活学习的一个监督和记录。<br>  <span id="more"></span></p>
<h2 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h2><ol>
<li><p>GitHub创建个人仓库（名称与用户名一致）  </p>
</li>
<li><p>git安装，绑定github密钥  </p>
<blockquote>
<p>git config –global user.name “你的GitHub用户名”<br>git config –global user.email “你的GitHub注册邮箱”  </p>
</blockquote>
<p> 生成ssh密钥文件：  </p>
<blockquote>
<p>ssh-keygen -t rsa -C “你的GitHub注册邮箱”</p>
</blockquote>
<p> 打开<a href="link" title="https://github.com/settings/keys">GitHub_Settings_keys</a> 页面，新建new SSH Key</p>
</li>
</ol>
<ol start="3">
<li><p>安装node.js，npm   </p>
</li>
<li><p>安装hexo：</p>
<blockquote>
<p>npm install -g hexo-cli   </p>
</blockquote>
<p> 博客初始化：</p>
<blockquote>
<p>hexo init blog</p>
</blockquote>
<p> 查看本地localhost是否成功  </p>
</li>
<li><p>修改.yml站点配置文件，绑定github  </p>
</li>
<li><p>绑定域名<br> 在blog\source下新建CNAME文件（无文件名）,例如：<br> XXX.top<br> 域名解析：建立CNAME解析，主机名分别为@和www，对应值都是你的 Github 个人主页地址  </p>
</li>
<li><p>最后hexo g,hexo d,就ok辣。  </p>
</li>
</ol>
<h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><p>npm install hexo -g #安装Hexo<br>npm update hexo -g #升级<br>hexo init #初始化博客<br>hexo n “我的博客” == hexo new “我的博客” #新建文章<br>hexo g == hexo generate #生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy #部署<br>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令  </p>
<h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><p>首先第一次搭建完成后，遇到了61行date的问题 ，一直没有解决，所以我选择了再次搭建，并且将此过程记录了下来。</p>
<ol>
<li>使用hexo命令显示无效  </li>
</ol>
<p><strong>注意需要在blog文件下进行操作</strong><br><strong>还有congig.yml 空格问题基本新手都会犯</strong><br>2. 执行hexo命令出现ERROR<br><strong>npm install 即可</strong><br>3. 前面都没有问题到了hexo d时候连接不上git<br><strong>所以不应用http 应该使用git</strong><br>4. 本地命令成功 但是localhost:访问不到网址<br><strong>大概率是端口占用了</strong><br>5. 本地可以访问但是用户名加github.io无法访问<br><strong>注意库名与用户名一致!!!</strong><br>6. 下载主题出现代理的问题<br>    <strong>查询是否使用代理：</strong><br>    &gt;git config –global http.proxy   </p>
<pre><code>**取消代理：**  
&gt;git config --global --unset http.proxy  
</code></pre>
<ol start="7">
<li>ERROR Process failed: about/index.md<br>TypeError: Cannot read property ‘utcOffset’ of null<br>折腾了半天发现原来站点的配置文件的timezone也就是时区必须要和主题的的配置文件一直，把这两个文件下的timezone都设为Asia/Shanghai就解决了</li>
<li>Cannot GET/xxx<br>查看index.html文件是否还在，可以参考<a href="link" title="https://www.jianshu.com/p/af83fc73e525">这个</a></li>
</ol>
<p style="color: #AD5D0F;font-size: 23px; font-family: '宋体';">附加功能：</p>

<hr>
<h3 id="1-打赏"><a href="#1-打赏" class="headerlink" title="1.打赏"></a>1.打赏</h3><ol>
<li>准备支付宝和微信二维码</li>
<li>在_config.yml中配置图片  <blockquote>
<p>reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！<br>wechatpay: /images/wechat.jpg<br>alipay: /images/aipay.png  </p>
</blockquote>
</li>
<li>wechat.jpg、alipay.png图片放入themes/next/source/images(主题配置)中</li>
<li>（解决文字闪烁问题）修改next/source/css/_common/components/post/post-reward.styl，注释wechat:hover和alipay:hover</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>hexo+github迁移电脑</title>
    <url>/2021/04/04/hexo-github%E8%BF%81%E7%A7%BB%E7%94%B5%E8%84%91/</url>
    <content><![CDATA[<h1 id="hexo个人博客迁移"><a href="#hexo个人博客迁移" class="headerlink" title="hexo个人博客迁移"></a>hexo个人博客迁移</h1><p>从一台电脑上迁移至另外一台电脑<br> <span id="more"></span></p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul>
<li>复制blog文件夹</li>
<li>在新的电脑上下载新的git和nodejs</li>
<li>npm install</li>
<li>安装hexo,重新部署。<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-nodejs版本过高"><a href="#1-nodejs版本过高" class="headerlink" title="1.nodejs版本过高"></a>1.nodejs版本过高</h3>  下载低版本13.14。<h3 id="2-Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists-（一般是公钥出问题）"><a href="#2-Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists-（一般是公钥出问题）" class="headerlink" title="2.Please make sure you have the correct access rights and the repository exists.（一般是公钥出问题）"></a>2.Please make sure you have the correct access rights and the repository exists.（一般是公钥出问题）</h3></li>
</ul>
<ol>
<li><blockquote>
<p>git config –global user.name “你的GitHub用户名”<br>git config –global user.email “你的GitHub注册邮箱”  </p>
</blockquote>
</li>
<li><p>删除.ssh文件夹（直接搜索该文件夹）下的known_hosts(手动删除即可，不需要git）</p>
</li>
<li><p>生成ssh密钥文件：  </p>
<blockquote>
<p>ssh-keygen -t rsa -C “你的GitHub注册邮箱”   </p>
</blockquote>
</li>
<li><p>打开<a href="https://github.com/settings/keys%22">GitHub_Settings_keys</a> 页面，新建new SSH Key，把密钥复制上去。</p>
<h3 id="3-遇见404问题"><a href="#3-遇见404问题" class="headerlink" title="3.遇见404问题"></a>3.遇见404问题</h3><p><a href="%22https://www.jianshu.com/p/2349c763cc02?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation%22">参考解决方法</a></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>javascript学习笔记</title>
    <url>/2019/01/21/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>参考菜鸟教程进行学习<br>  <span id="more"></span></p>
<h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><p>HTML 中的脚本必须位于 <script> 与 </script> 标签之间。脚本可被放置在 HTML 页面的 <body> 和 <head> 部分中，也可以保存在外部文件中（则不需要加标签）。</head></body></p>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><ul>
<li>使用 window.alert() 弹出警告框。</li>
<li>使用 document.write() 方法将内容写到 HTML 文档中。</li>
<li>使用 innerHTML 写入到 HTML 元素。</li>
<li>使用 console.log() 写入到浏览器的控制台。  </li>
</ul>
<script>
    var y;
    var z;
    var d;
x=document.getElementsByClassName("Barrage-listItem");
y=document.getElementById(x[0].id);
d=y.getElementsByTagName("div");
var reg = /Barrage-userEnter/i;    
console.log(reg.test(d[0].className)); 
console.log(d[0].className);
if(reg.test(d[0].className))
{
z=y.getElementsByTagName("span");
console.log(z[2].title);
d[0].className="b";
}
</script>

]]></content>
  </entry>
  <entry>
    <title>markdown</title>
    <url>/2020/05/05/markdown/</url>
    <content><![CDATA[<ul>
<li>空格<br>输入 &amp;nbsp;</li>
<li>空行<br>输入 &amp;emsp;</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>python爬虫初学</title>
    <url>/2019/02/09/python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/</url>
    <content><![CDATA[<p>#coding:utf-8</p>
<span id="more"></span>
<p>#author:Ericam_</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import urllib.request</span><br><span class="line">import time</span><br><span class="line">headers = (&#x27;User-Agent&#x27;, &#x27;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&#x27;)</span><br><span class="line">opener = urllib.request.build_opener()</span><br><span class="line">opener.addheaders = &#123;headers&#125;</span><br><span class="line">urllib.request.install_opener(opener)</span><br><span class="line">def get_download(url):</span><br><span class="line">    file = urllib.request.urlopen(url)</span><br><span class="line">    data = BeautifulSoup(file , from_encoding=&quot;utf8&quot;)    </span><br><span class="line">    section_name = data.title.string</span><br><span class="line">    print(section_name)</span><br><span class="line">    section_text = data.select(&#x27;#content #left font&#x27;)[0].text</span><br><span class="line">    section_text=re.sub( &#x27;\s+&#x27;, &#x27;\r\n\t&#x27;, section_text).strip(&#x27;\r\n&#x27;)</span><br><span class="line">    fp = open(&quot;D:/python/2.txt&quot;,&#x27;a&#x27;,encoding=&#x27;utf-8&#x27;)   </span><br><span class="line">    fp.write(section_name+&#x27;\n&#x27;)  </span><br><span class="line">    fp.write(section_text+&#x27;\n&#x27;)  </span><br><span class="line">    fp.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    url = &quot;http://www.net767.com/shuji/fubaba/10995.html&quot;</span><br><span class="line">    while(True):</span><br><span class="line">        file = urllib.request.urlopen(url)</span><br><span class="line">        data = BeautifulSoup(file , from_encoding=&quot;utf8&quot;)    </span><br><span class="line">        section_name = data.title.string</span><br><span class="line">        print(section_name)</span><br><span class="line">        section_text = data.select(&#x27;#content #left font&#x27;)[0].text</span><br><span class="line">        section_text=re.sub( &#x27;\s+&#x27;, &#x27;\r\n\t&#x27;, section_text).strip(&#x27;\r\n&#x27;)</span><br><span class="line">        print(section_text)</span><br><span class="line">        txt_section=data.select(&#x27;#pagebar a&#x27;)</span><br><span class="line">        l1=len(txt_section)</span><br><span class="line">        for num in range(1,l1-1):</span><br><span class="line">            y=txt_section[num][&#x27;href&#x27;]</span><br><span class="line">            url = &quot;http://www.net767.com&quot;+y</span><br><span class="line">            get_download(url)</span><br><span class="line">            print(y)</span><br><span class="line">        txt2_section=data.select(&#x27;.LinkNextArticle&#x27;)</span><br><span class="line">        y2=txt2_section[0][&#x27;href&#x27;]</span><br><span class="line">        url = &quot;http://www.net767.com&quot;+y2</span><br><span class="line">        if(url == &#x27;http://www.net767.com/shuji/fubaba/11003_9.html&#x27;):</span><br><span class="line">            break</span><br><span class="line">        print(y2)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2021/05/27/test/</url>
    <content><![CDATA[<h1 id="多电脑使用hexo博客"><a href="#多电脑使用hexo博客" class="headerlink" title="多电脑使用hexo博客"></a>多电脑使用hexo博客</h1><ul>
<li><p>【Hexo异常】fatal: in unpopulated submodule ‘.deploy_git’</p>
<p><a href="https://blog.csdn.net/nomasp/article/details/79504699"></a></p>
</li>
<li><h1 id="Window下完全卸载删除Nodejs"><a href="#Window下完全卸载删除Nodejs" class="headerlink" title="Window下完全卸载删除Nodejs"></a><a href="https://www.cnblogs.com/fighxp/p/7410235.html">Window下完全卸载删除Nodejs</a></h1></li>
<li><h1 id="nvm安装（Windows篇-https-www-jianshu-com-p-13c0b3ca7c71"><a href="#nvm安装（Windows篇-https-www-jianshu-com-p-13c0b3ca7c71" class="headerlink" title="nvm安装（Windows篇)https://www.jianshu.com/p/13c0b3ca7c71"></a>nvm安装（Windows篇)<a href="https://www.jianshu.com/p/13c0b3ca7c71">https://www.jianshu.com/p/13c0b3ca7c71</a></h1></li>
</ul>
<p>如果先安装node，再安装nvm，可能会出现修改后，版本仍然未变的情况，尝试了网上很多方法，建议还是卸载重新安装降低版本的node.js</p>
]]></content>
  </entry>
  <entry>
    <title>个人随笔</title>
    <url>/2019/01/20/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h1 id="1月20记"><a href="#1月20记" class="headerlink" title="1月20记"></a>1月20记</h1><span id="more"></span>
<p>好久没有写日记了，下午和从小长大的朋友聊了会天，真的感觉时间过的好快。而且似乎到了什么年龄，周围的人就会询问关心你这个年龄应该干的事情做的怎么样。就好像上学期间就是学校的好坏，工作期间就是结婚工资。那么究竟你是变得更好还是会更烂呢？  </p>
<ol>
<li>考研信息，结课作业。1.21到1.25  </li>
<li>英语单词，阅读。寒假每天坚持</li>
<li>线代复习，真题。寒假每天坚持<br>视频每天3个，加看辅导书。</li>
<li>javascrip,css,html。 </li>
<li>python,爬虫项目。 1.28到2.2  </li>
<li>实验室论文，深度学习。 2.2以后</li>
<li>小程序项目   1.28到2.2</li>
<li>java  2.2以后<br>前三个尽量做完，4，5，7完成一二即可，6，8能入门就再好不过了。  <h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2></li>
</ol>
<ul>
<li>旅游（估计难了 555）</li>
<li>联系一下朋友同学 （加油嗷）</li>
<li>吃饭，作息规律 （一定可以的）</li>
<li>读完3本书 (穷爸爸，富爸爸  如何阅读一本书  自控力)</li>
<li>想到的再继续补充~</li>
</ul>
<h2 id="2-8到2-20（11天）"><a href="#2-8到2-20（11天）" class="headerlink" title="2.8到2.20（11天）"></a>2.8到2.20（11天）</h2><ul>
<li>线代每天两个视频，辅导讲义写完  3</li>
<li>英语一个单元   2.5（课听完）</li>
<li>看书1个小时   </li>
<li>查考研信息    问问问</li>
<li>健身刷牙</li>
<li>python斗鱼的项目</li>
<li>小程序的项目</li>
<li></li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>抛弃浮躁，脚踏实地。</p>
<h2 id="英语："><a href="#英语：" class="headerlink" title="英语："></a>英语：</h2><ul>
<li>单词：</li>
</ul>
<ol>
<li>高频单词视频看完 （2月之前）</li>
<li>每天1个list背诵</li>
<li>空闲时间刷百词斩</li>
</ol>
<ul>
<li>阅读：</li>
</ul>
<ol>
<li>3.4月份：08年之前的真题阅读精读（一天一篇）+网课学习  暂定3个小时</li>
<li>5，6，7 做完所有真题阅读  </li>
<li>8，9，10 作文，翻译，完型  暂定<h2 id="数学："><a href="#数学：" class="headerlink" title="数学："></a>数学：</h2></li>
</ol>
<ul>
<li>线代：</li>
</ul>
<ol>
<li>两天一章，视频+讲义+课本看完（2月底）</li>
<li>暂定暑假过第二遍</li>
</ol>
<ul>
<li>高数：</li>
</ul>
<ol>
<li>3，4月刷高数18讲+书+记笔记（第一遍）</li>
<li>后来暂定</li>
</ol>
<ul>
<li>概率论：</li>
</ul>
<ol>
<li>5或6月份<h2 id="专业课："><a href="#专业课：" class="headerlink" title="专业课："></a>专业课：</h2></li>
<li>大概确定院校！！！</li>
<li>背书</li>
<li>真题<h2 id="政治："><a href="#政治：" class="headerlink" title="政治："></a>政治：</h2></li>
<li>9月份大纲确定开始</li>
</ol>
<h2 id="时间安排：（暂定，根据具体情况会调整）"><a href="#时间安排：（暂定，根据具体情况会调整）" class="headerlink" title="时间安排：（暂定，根据具体情况会调整）"></a>时间安排：（暂定，根据具体情况会调整）</h2><ol>
<li>6：30~6：40洗漱</li>
<li>6：40~7：00吃早饭</li>
<li>7：10~8：00背单词</li>
<li>8：00~12：00</li>
<li>12：00~12：20吃饭</li>
<li>12：20~1：10休息</li>
<li>1：30~4：30</li>
<li>4：40~5：30健身</li>
<li>5：30~5:50吃饭</li>
<li>6：00~6：20洗澡</li>
<li>6：30~11:00</li>
<li>11:00~11:30洗漱，处理部分事情，睡觉</li>
</ol>
<ul>
<li>补充：</li>
</ul>
<ol>
<li>根据上课的时间进行有效调整</li>
<li>最重要的是把每天的任务计划都要提前列出来并且完成</li>
<li>咨询考研相关信息（学校，实验室，导师，考研参考书，学习方法，有效途径，询问学长学姐老师同学）放在中午12：00<del>1：30，4：30</del>6；30，11：00以后  其他时间不要看！！！</li>
<li></li>
</ol>
<ul>
<li>3.8</li>
</ul>
<ol>
<li>7点起来 洗漱，吃饭。</li>
<li>8点到9点背单词和句子</li>
<li>9点到11点看英语视频</li>
<li>11点去吃饭+问王伟考研学校+专业课考什么</li>
<li>2点到4：30点看线代视频</li>
<li>4：30~6：30 健身，吃饭，洗澡</li>
<li>6：30~10：00 高数</li>
<li>买参考书</li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(斐波那契数列)</title>
    <url>/2020/02/17/%E5%89%91%E6%8C%87offer(%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91)/</url>
    <content><![CDATA[<ul>
<li>避免递归造成的调用栈消耗<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        int b = 1;</span><br><span class="line">        while(n--&gt;0)&#123;</span><br><span class="line">            b = a + b;</span><br><span class="line">            a = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度<br>时间复杂度：O(n)O(n)<br>空间复杂度：O(1)O(1)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>正则获取词缀集</title>
    <url>/2020/05/05/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="从词典中获取词缀集"><a href="#从词典中获取词缀集" class="headerlink" title="从词典中获取词缀集"></a>从词典中获取词缀集</h1><span id="more"></span>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">f = open(&quot;C:/Users/张金元/Desktop/a.txt&quot;, &quot;r&quot;, encoding=&#x27;utf-8&#x27;)     #打开a.txt文件，以只读得方式，注意编码格式，含中文</span><br><span class="line">data = f.readlines()                            #循环文本中得每一行，得到得是一个列表的格式&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">f.close()                                       #关闭a.txt文件</span><br><span class="line">for line in data:</span><br><span class="line">    result = re.findall(&#x27;-(\w*\w)\s+&#x27;,line)     #使用正则表达式筛选每一行的数据,自行查找正则表达式   取得后缀</span><br><span class="line">    result1 = list(set(result))          #去掉重复后缀</span><br><span class="line">    result1.sort(key=result.index)       #按照之前的list排序</span><br><span class="line">    print(&quot;res1:%s&quot; % result1)</span><br><span class="line">for i in result1:</span><br><span class="line">    f1 = open(&quot;C:/Users/张金元/Desktop/c.txt&quot;, &quot;a+&quot;, encoding=&#x27;utf-8&#x27;)          #新建一个c.txt文本，已追加的方式写入</span><br><span class="line">    f1.write(i + &#x27;\n&#x27;)  # 将每一行打印进c.txt文件并换行</span><br><span class="line">    f1.close()  # 关闭c.txt文件**</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<h2 id="python-txt操作"><a href="#python-txt操作" class="headerlink" title="python txt操作"></a>python txt操作</h2><ul>
<li>打开文件：f = open(“test.txt”, ‘操作模式’)    #”test.txt”文本操作路径</li>
<li>w ——————————– 只能写入，如果之前有文件，则会被覆盖</li>
<li>r ——————————– 只能读取</li>
<li>a ——————————– 向文件追加</li>
<li>w+ ——————————– 可读可写</li>
<li>r+ ——————————– 可读可写</li>
<li>a+ ——————————– 可读可追加</li>
<li>wb+ ——————————写入进制文件<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3></li>
<li>.                    匹配任意字符（不包括换行符）</li>
<li>^                    匹配开始位置，多行模式下匹配每一行的开始</li>
<li>$                    匹配结束位置，多行模式下匹配每一行的结束</li>
<li>*                    匹配前一个元字符0到多次</li>
<li>+                    匹配前一个元字符1到多次</li>
<li>?                    匹配前一个元字符0到1次</li>
<li>{m,n}                匹配前一个元字符m到n次</li>
<li>\\                   转义字符，跟在其后的字符将失去作为特殊元字符的含义，例如\.只能匹配.，不能再匹配任意字符</li>
<li>[]                   字符集，一个字符的集合，可匹配其中任意一个字符</li>
<li>|                    逻辑表达式 或 ，比如 a|b 代表可匹配 a 或者 b</li>
<li>(…)                分组，默认为捕获，即被分组的内容可以被单独取出，默认每个分组有个索引，从 1 开始，按照”(“的顺序决定索引值</li>
<li>(?iLmsux)            分组中可以设置模式，iLmsux之中的每个字符代表一个模式,用法参见 模式 I</li>
<li>(?:…)              分组的不捕获模式，计算索引时会跳过这个分组</li>
<li>(?P<name>…)        分组的命名模式，取此分组中的内容时可以使用索引也可以使用name</name></li>
<li>(?P=name)            分组的引用模式，可在同一个正则表达式用引用前面命名过的正则</li>
<li>(?#…)              注释，不影响正则表达式其它部分,用法参见 模式 I</li>
<li>(?=…)              顺序肯定环视，表示所在位置右侧能够匹配括号内正则</li>
<li>(?!…)              顺序否定环视，表示所在位置右侧不能匹配括号内正则</li>
<li>(?&lt;=…)             逆序肯定环视，表示所在位置左侧能够匹配括号内正则</li>
<li>(?&lt;!…)             逆序否定环视，表示所在位置左侧不能匹配括号内正则</li>
<li>(?(id/name)yes|no)   若前面指定id或name的分区匹配成功则执行yes处的正则，否则执行no处的正则</li>
<li>\number              匹配和前面索引为number的分组捕获到的内容一样的字符串</li>
<li>\A                   匹配字符串开始位置，忽略多行模式</li>
<li>\Z                   匹配字符串结束位置，忽略多行模式</li>
<li>\b                   匹配位于单词开始或结束位置的空字符串</li>
<li>\B                   匹配不位于单词开始或结束位置的空字符串</li>
<li>\d                   匹配一个数字， 相当于 [0-9]</li>
<li>\D                   匹配非数字,相当于 [^0-9]</li>
<li>\s                   匹配任意空白字符， 相当于 [ \t\n\r\f\v]</li>
<li>\S                   匹配非空白字符，相当于 [^ \t\n\r\f\v]</li>
<li>\w                   匹配数字、字母、下划线中任意一个字符， 相当于 [a-zA-Z0-9_]</li>
<li>\W                   匹配非数字、字母、下划线中的任意字符，相当于 [^a-zA-Z0-9_]   </li>
</ul>
<p><strong><a href="https://www.cnblogs.com/dyfblog/p/5880728.html"></a></strong><br><strong><a href="https://www.cnblogs.com/a-small-Trainee/p/12825685.html"></a></strong><br>###<br><strong><a href="https://blog.csdn.net/qq_20412595/article/details/82633501">正则表达式以及group的用法</a></strong></p>
]]></content>
      <categories>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言</title>
    <url>/2019/02/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="数据寻址方式"><a href="#数据寻址方式" class="headerlink" title="数据寻址方式:"></a>数据寻址方式:</h3><ul>
<li>CPU:</li>
</ul>
<ol>
<li>立即寻址方式</li>
<li>寄存器寻址方式</li>
</ol>
<ul>
<li>存储器：</li>
</ul>
<ol>
<li>直接寻址方式</li>
<li>间接寻址方式</li>
<li>相对寻址方式</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>考研</title>
    <url>/2019/03/24/%E8%80%83%E7%A0%94/</url>
    <content><![CDATA[<span id="more"></span>
<pre><code>失败不是终点，找好工作再说8
</code></pre>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记2</title>
    <url>/2019/02/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h1 id="项目（秒杀系统）"><a href="#项目（秒杀系统）" class="headerlink" title="项目（秒杀系统）"></a>项目（秒杀系统）</h1><span id="more"></span>
<ul>
<li><p>集合(collection)：<br>  数组的长度是固定的，集合的长度是可变的。<br>  每一个容器的数据结构不一样<br>  Collection接口定义着集合框架中最最共性的内容<br>  size(); add(); remove(); clear(); contains(); toArray();<br>  集合的遍历：<br>  在根接口中使用了一种公共的遍历方式，迭代器遍历</p>
<ol>
<li>获取一个集合的迭代器对象(迭代器对象不是我们创建的，而是每个集合自带的) 是一个接口<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = names.iterator();</span><br><span class="line">while(it.hasnext())&#123;</span><br><span class="line">    String s = it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
java规定，如果一个集合使用迭代器遍历，那么遍历的过程中，不允许修改集合长度</li>
<li>增强for循环<br>Collection<String> names = new ArrayList<String>();<br>for(数据类型 变量名：数组/集合){<br> syso(变量名);<br>}<br>使用增强for循环遍历集合的时候，不能修改集合的长度</String></String></li>
<li>泛型:E实际上是一个“变量”  用来保存一种数据类型<br> <E>,&lt;K,V&gt;<br> 可以用在类，方法，接口上。<br> 泛型通配符<br> ？：代表任意类型</E></li>
<li>Collections.shuffle(cards); //洗牌</li>
<li>栈，队列<br>数组结构  Arraylist   Vector   查询快，增删慢<br>链表结构：一般使用双向链表<br>哈希表结构：查询快 增删快</li>
<li>List接口特点：有下标，有序的，可重复<br>实现类：ArrayList,LinkedList,Vector 安全<br>List结构中的方法：<br>增：add(E e);  add(int index,E e)<br>删：remove(Object obj);remove(int index);<br>改：set(int index,E e);<br>查：get(int index);<br>其他：<br> size();clear(),contains(Object obj),toArray();<br> iterator();isEmpty();</li>
<li>ArrayList:方法基本和List一致  </li>
<li>LinkedList:还有大量的首尾操作方法<br>void addFirst(E e);<br>E removeFirst();<br>E getFirst();<br>E pop();  和removeFirst一致<br>void push(E e);   推入  和addFirst一致</li>
<li>Set接口<br>a.无下标<br>b.无序的<br>c.不可重复<br>实现类：<br>HashSet：底层采用哈希表结构，查询快，增删快，无序的<br>LinkedHashSet:链表＋哈希表，查询快，增删快，有序<br>Set接口中的特有方法和Collection基本一致<br>TreeSet:红黑树</li>
<li>哈希表<br>哈希值：每一个对象都具有哈希值<br>地址值实际是哈希值的16进制<br>String对象的哈希值：重写了Object类中的hashCode<br>不再通过地址值计算 只和字符串内容相关<br>哈希表结构，添加元素判断是否重复</li>
<li>先判断新旧元素的哈希值</li>
<li>再判断新旧元素的equals<br>自定义类，要使用HashSet存储<br>保证元素唯一性：<br>  必须重写自定义类的两个方法  hashcode   equals<br>定义一个标准得类：</li>
<li>封装</li>
<li>构造</li>
<li>toString</li>
<li>hashCode equals<br>contains方法：<br>ArrayList:names.contains(“abc”);<br>HashSet:set.contains(“abc”);</li>
<li>Map接口<br>Map&lt;K,V&gt;集合常用方法： 、<br>HashMap<br>增：put(K key,V value);  //向集合中添加键值对<br>//如果集合中已存在该键，覆盖整个键值对，并返回被覆盖的键值对的值<br>判断k是不是空<br>哈希表结构，添加元素判断是否重复</li>
<li>先判断新旧元素的哈希值</li>
<li>再判断新旧元素的equals<br>删：v remove(object key);  //返回被删除的键值对的值<br>改：==put<br>查：V get(K key);  判断是不是空<br>Map集合遍历：   LinkedHashMap   HashMap<br>getKey();<br>getValue();</li>
<li>keySet遍历<br>Set<Student> keys = students.keySet();  //放在set集合中<br>map.KeySet(); Iterator  hasnext<br>for(String key : keys)<br>{<br>  String value = students.get(key);<br>}</Student></li>
<li>Set&lt;Map.Entry<String string="">&gt; entrySet = map.entrySet();<br>Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = entrySet.iterator();<br>while(it.hasNext(){<br>  Map.Entry&lt;String, String&gt; entry = it.next();<br>  String key = entry.getKey();<br>  String value = entry.getValue();<br>  system.out.println(key+”=”+value)；<br>})<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Set;</span><br><span class="line">  </span><br><span class="line">public class MapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        //map集合存入数据</span><br><span class="line">        map.put(1, &quot;第一个value&quot;);</span><br><span class="line">        map.put(2, &quot;第二个value&quot;);</span><br><span class="line">        map.put(3, &quot;第三个value&quot;);</span><br><span class="line">         </span><br><span class="line">        //通过keySet取出map数据[for-each循环]</span><br><span class="line">        System.out.println(&quot;-------[for-each循环遍历]通过keySet取出map数据-------&quot;);</span><br><span class="line">        Set&lt;Integer&gt; keys = map.keySet();  //此行可省略，直接将map.keySet()写在for-each循环的条件中</span><br><span class="line">        for(Integer key:keys)&#123;</span><br><span class="line">            System.out.println(&quot;key值：&quot;+key+&quot; value值：&quot;+map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //通过EntrySet取出map数据[for-each循环]</span><br><span class="line">        System.out.println(&quot;-------[for-each循环遍历]通过EntrySet取出map数据-------&quot;);</span><br><span class="line">        Set&lt;Entry&lt;Integer, String&gt;&gt; entrys = map.entrySet(); //此行可省略，直接将map.entrySet()写在for-each循环的条件中</span><br><span class="line">        for(Entry&lt;Integer, String&gt; entry:entrys)&#123;</span><br><span class="line">            System.out.println(&quot;key值：&quot;+entry.getKey()+&quot; value值：&quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //通过keySet取出map数据[Iterator遍历]</span><br><span class="line">        System.out.println(&quot;-------[Iterator循环遍历]通过keySet取出map数据---------&quot;);</span><br><span class="line">        Iterator&lt;Integer&gt; it = map.keySet().iterator(); //map.keySet()得到的是set集合，可以使用迭代器遍历</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">            Integer key = it.next();</span><br><span class="line">            System.out.println(&quot;key值：&quot;+key+&quot; value值：&quot;+map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //通过EntrySet取出map数据[Iterator遍历]</span><br><span class="line">        System.out.println(&quot;-------[Iterator循环遍历]通过EntrySet取出map数据---------&quot;);          </span><br><span class="line">        Iterator&lt;Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator(); //map.entrySet()得到的是set集合，可以使用迭代器遍历</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(&quot;key值：&quot;+entry.getKey()+&quot; value值：&quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
内部类：<br>OutClass.InterClass ic = new OutClass.new InterClass();<br>内部接口    实现谁，重写谁<br>如果Map中的键是自定义类型，那么要保证键的唯一性，必须重写键对应类的hashCode和equals方法</String></li>
<li>Properties类<br>本质就是一个Map集合<br>持久的属性集<br>ps.store(new FileWriter(“phones.properties”),””);//存<br>ps.load(new FileReader(“phones.properties)); //读取<br>没有泛型<br>具有Map接口的一切方法，以及自己特有的<br>getProperty();<br>setProperty();<br>public Set<String> stringPropertyNames();//和KeySet一样<br>Properties ps = new Properties();<br>可变参数：<br>public static int add(int…a){<br>  return 0;<br>}<br>//类型不能改变，多个参数时，可变参数在最后面<br>本质：数组  for(int i : a)<br>Collections：(集合工具类)中的静态方法：<br>public static void shuffle(List list);//打乱顺序<br>public static void sort(List list);//把集合元素按照自然顺序排序<br>Arrays:数组工具类<br>public static List asList(数组/可变参数); //把数组转化为List集合<br>Arrays.sort(nums);<br>Arrays.toString(nums);<br>Map集合的嵌套：</String></li>
</ol>
</li>
<li><p>File类</p>
<ol>
<li>File类可以表示文件  也可以表示文件夹<br>构造：<br> 1.public File(String filepath);<br> 绝对路径：以盘符开头的路径<br> 相对路径：相对当前项目的根目录<br> 2.public File(String parent ,String child);<br> 3.public File(File parent,String child);</li>
<li>File对象的获取方法<br>public String getAbsolutePath();//获取绝对路径<br>getName();  getPath();<br>public long length(); //获取File对象(文件)的字节数  不能计算文件夹</li>
<li>File对象的删除和创建方法：</li>
<li>创建方法<br>  创建文件：<pre><code>  public boolean creatNewFile(); //创建新的文件
</code></pre>
  创建文件夹<pre><code>  public boolean mkdir();
</code></pre>
</li>
<li>判断方法<br>  判断是否是文件<pre><code>  public boolean isFile();
</code></pre>
  判断是否是文件夹<pre><code>  public boolean isDirectory();
</code></pre>
  判断是否存在<pre><code>  public boolean exists();
</code></pre>
</li>
<li>删除<pre><code>  public boolean delete();
</code></pre>
</li>
<li>File类下的list和listFiles方法(文件夹)<br>  1.public String[] list();<br>  2.public File[] listFiles();<br>  只能列出当前文件下的一级子文件或者子文件夹<br>  扩展：删除先删文件再删文件夹</li>
<li>递归打印目录下的所有文件</li>
<li>文件过滤器：FileFilter<br>在list和listFiles方法中使用</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记2</title>
    <url>/2019/02/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h2 id="io-多线程-网络编程-XML"><a href="#io-多线程-网络编程-XML" class="headerlink" title="io 多线程  网络编程  XML"></a>io 多线程  网络编程  XML</h2><span id="more"></span>
<ul>
<li><p>IO流<br>  1.字符流,字节流<br>  字符输入流：共同的父类Reader  比如FileReader,BufferedReader</p>
<pre><code>  功能：读取一个字符，读取一个字符数组(一部分)，读取一个字符串
</code></pre>
<p>  字符输出流：共同的父类Writer  比如FileWriter,BufferedWriter</p>
<pre><code>  功能：写一个字符，写一个字符数组(一部分)，写一个字符串
</code></pre>
<p>  字节输入流：共同父类 InputStream  比如：FileInputStream,BufferInputStream    读取一个字节   读取一个字节数组<br>  字节输出流：共同父类 OutputStream  比如：FileOutputStream,BufferOutputStream    写一个字节   写一个字节数组<br>  2.OutputStream:字节输出流的根类，这是一个抽象类<br>  public void close();<br>  public void flush(); //刷新流<br>  public void write(int b); //写一个字节<br>  public void write(byte[] bs); //写一个字节数组<br>  public void writre(byte[] bs,int startIndex, int lenght);//写一个字节数组的一部分<br>  3.续写和换行<br>  FileOutputStream fos = new FileOutputStream(“2.txt”,true);<br>  fos.write(“\r\nhello”.getBytes());<br>  fos.close();<br>  4.InputStream:字节输入流的根类，这是一个抽象类<br>  1.public int read();、、读取一个字节，返回是码值<br>  2.public int read(byte[] bs);//读取一个字节数组，返回值表示实际读取到的字节数<br>  我们用InputStream具体子类：FileInputStream<br>  一次读取一个字节<br>  FileIntputStream fis = new FileIntputStream(new File(“1.txt”));<br>  int b = 0;<br>  while(b=fis.read()!=-1)<br>  {</p>
<pre><code>  System.out.println((char)b);
</code></pre>
<p>  }<br>  fis.close();<br>  一次读取一个字节数组<br>  byte[] bs = new byte[4];<br>  int len = fis.read(bs);<br>  System.out.println(len); //实际字节数<br>  System.out.println(new String(bs));<br>  标准：<br>  while((len = fis.read(bs)!=-1))<br>  {</p>
<pre><code>  System.out.println(new String(bs,0,len))
</code></pre>
<p>  }<br>  复制文件：<br>  long s= System.currentTimeMillis(); //系统时间<br>  while((len = fis.read(bs)!=-1))<br>  {</p>
<pre><code>  fos.writ(bs,0,len);
</code></pre>
<p>  }<br>  字节缓冲流：<br>  BufferedOutputStream bos = new BufferedOutputStream(new FileOutputaStream(“1.txt”));<br>  字节流读取中文的乱码问题：读取中文读了一半<br>  解决问题：字符流  转化流<br>  字符编码表(字符集)<br>  ASCII码表<br>  在GBK码表中一个中文2个字节 在UTF-8中一个中文 3个字节<br>  OutputStreamWriter  是字符流通向字节流的桥梁，查码表(编码)<br>  OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(“1.txt”));<br>  osw.close();<br>  字节-&gt;解码-&gt;字符： InputStreamReader<br>  字符-&gt;编码-&gt;字节： OutputStreamWriter<br>  transient关键字：<br>  用来修饰成员变量 用不用没有影响<br>  序列化的时候有用，如果一个成员变量被transient修饰，那么序列化的时候会忽略该成员变量<br>  static:关键字 他也具有和transient一样的功能<br>  打印流：<br>  PrintWriter:打印字符流<br>  PrintyStream:打印字节流</p>
<p>  使用第三方框架的步骤<br>  1.导入classpath<br>  a.在工程根目录下 建立一个目录”lib”<br>  b.把要使用的第三方框架的jar包拷贝过来<br>  c.添加构建路径 右键单击jar包—-&gt;Build Path —-&gt; Add to Build Path<br>  以FileUtils为例</p>
</li>
<li><p>多线程</p>
<ol>
<li>内存RAM  硬盘ROM<br>多线程程序并不能提高程序的运行速度，但能够提高程序运行速率，让cpu的使用率更高。<br>main方法所在线程  我们就称为主线程<br>Thread类：线程类<br>public Thread();//创建一个默认名字的线程对象<br>public Thread(String name);//创建一个指定名字的线程对象<br>第一种：继承<br>class 子线程类 extends Thread{<br> run(){<pre><code> 任务代码
</code></pre>
 }<br>}<br>子线程类 t = new 子线程类();<br>t.start();<br>第二种：声明实现Runable接口的类，重写run方法，创建实现类对象，创建Thread对象，并把刚刚的实现类对象 作为参数传递，启动这个Thread对象<br>从耦合性分析用第二种<br>扩展性:第一种继承Thread，那么子线程类就不能继承别的类<br>第二种方式  由于是实现了接口，同时可以继承别的类<br>匿名内部类创建线程对象</li>
<li>new Thread(){<br> public void run(){<pre><code> /////////
</code></pre>
 }<br>}.start();</li>
<li>new Thread(new Runnable(){<br> public void run(){<pre><code> /////
</code></pre>
 }<br>}).start();<br>线程安全问题：1.同步锁  synchronized(obj)</li>
<li>同步方法:<br>public synchronized void sale()<br>{<br>}<br>这里同步方法使用的锁对象  叫做this对象<br>这里同步方法是静态方法，那么他的锁对象是当前类.class</li>
<li>lock接口方式<br>实现类：ReentrantLock</li>
</ol>
</li>
<li><p>网络编程  udp  tcp<br>  InetAddress</p>
</li>
<li><p>XML语法<br>  文档说明：</p>
  <?xml version="1.0 encoding="TTF-8"?>
<p>  作用：存放数据  配置文件<br>  CDATA区 <!--[CDATA[]]--></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础学习1</title>
    <url>/2020/01/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<ol>
<li><p>类的概念：<br> 一堆具有共同的成员变量、属性和成员方法、功能对象集合</p>
</li>
<li><p>接口的概念：<br> 接口是功能的集合，就是方法的集合<br> 也就是说 接口中只能定义方法，不能定义普通的成员变量<br> 而且接口中的成员方法，必须都是抽象的<br> 接口是比抽象类还要抽象的一种类型</p>
<span id="more"></span>
<p> 问题：接口能创建对象吗？不能</p>
<pre><code> 接口作用：天生作为“父接口”
</code></pre>
</li>
<li><p>接口的定义：<br> 定义接口用关键字：interface<br> 定义枚举用关键字：enum</p>
<p> 格式：<br> public interface 接口名字{</p>
<pre><code> //成员变量，不能定义普通的成员变量
 //成员方法：必须都是抽象
 public abstract 返回值类型 方法名();
</code></pre>
<p> }</p>
<p> 类和接口的本质区别不大，他们的源码都是.java文件<br> 编译后都是.class文件</p>
</li>
<li><p>类与类之间：继承，而且是单继承，一个子类，只能有一个直接父类<br> 接口和接口之间:继承，但是可以多继承，一个子接口 可以有多个直接父接口</p>
<p> 面试题：Java到底支不支持多继承？</p>
<pre><code> 如果是类与类  不支持多继承  只支持多层继承
 如果是接口和接口  支持多继承  也支持多层继承
</code></pre>
<p> 类和接口之间：不叫继承(extends),叫实现(implements),可以多实现</p>
<pre><code> 只有类 实现接口
</code></pre>
</li>
<li><p>接口中成员的特点<br> 5.1成员变量，但是必须有固定修饰符public static final 数据类型 变量 = 值<br> 5.2成员方法，必须是固定修饰符public abstract 即抽象方法<br> 5.3接口不可以创建对象(抽象类也是)<br> 5.4实现类 实现类接口，那么必须重写接口中所有的抽象方法，然后才能创建对象</p>
<pre><code> 否则 这个实现类 还是一个抽象类，是不能创建对象的
 在开发中最常用的模式：
     public class A extends AbstractClassB implements 接口A，接口B&#123;
         注意：
         A中必须重写 抽象类中的抽象方法，以及所有接口中的抽象方法
     &#125; 
</code></pre>
</li>
<li><p>接口和抽象类的异同：</p>
</li>
<li><p>相同点：<br>  a.都不能创建对象<br>  b.都是作为父类/父接口<br>  c.子类/实现类 都必须重写抽象方法，然后才能创建对象</p>
</li>
<li><p>不同点：<br>  a.抽象类用关键字abstract  接口用关键字interface<br>  b.接口中只要有方法，必须都是抽象的<br>  c.抽象类可以定义任意成员变量  接口的成员变量必须public static final修饰<br>  d.类和抽象类之间关系是单继承，类和接口之间关系是多实现<br>  e.思想上的区别<br>  1.抽象类中必须定义整个继承体系中的共性内容<br>  2.接口中定义 整个继承体系之外的 额外扩展的功能。</p>
</li>
</ol>
<p>7.面向对象3大特征：封装(安全性)，继承(扩展性)，多态(灵活性)<br>    多态：<br>    前提1.必须有子父类关系<br>        2.必须有方法的重写<br>    多态在Java中的表现形式：<br>        父类类型  变量名 = new 子类类型();<br>        接口类型  变量名 = new 实现类();<br>        Animal an = new Cat();<br>        父类类型的变量指向了子类的对象<br>    注意：<br>        1.使用多态调用成员变量<br>            编译时，看父类<br>            运行时，看父类<br>        2.使用多态调用成员方法<br>            编译时，看父类<br>            运行时，看子类<br>总结：<br>    弊端：多态只能调用子父类共有的方法，不能调用子类特有的方法<br>    好处：提高灵活性<br>    父类类型的变量，可以接收任何一个子类的对象<br>    调用方法的时候，编译是看父类，运行时运行的传递过来的子类对象的方法<br>    弊端的解决方案：<br>        向下转型：强制类型转换<br>        向上转型：自动类型转换 (就是多态)<br>    向下转型也有弊端：<br>        把父类的变量 转成任何子类类型时候，编译器直接通过<br>        可以转成cat,本质是dog 所以出错<br>    Java中解决向下转型弊端的方法：<br>        一个关键字Instanceof 运算符<br>        作用：判断某一个变量 不是 该类的类型<br>        格式：<br>            boolean b = an instanceof 类名<br>    多态提高程序的灵活性，扩展性，复用性。</p>
<ol start="7">
<li><p>static的介绍:<br> static的作用用来修饰类中的成员<br> 1.如果一个类的成员被static修饰了，怎么访问？ 类名.成员变量名<br> 存在方法区中的静态区，只有一个空间  优先于对象存在<br> 2.类名.成员变量(推荐)   对象.成员变量   都可以<br> 3.所有对象共有的，被staic修饰的成员属于类，不属于单个对象<br> 4.静态没有多态性 静态不属于对象，属于类<br> 5.静态代码块：</p>
<pre><code> 在类的成员位置
     static&#123;
         代码
     &#125;
</code></pre>
<p> 特点：<br> 使用到这个类时，JVM会自动执行静态代码块<br> 只会第一次使用时执行<br> 优先级比构造方法高，比main方法高<br> 作用：用来初始化类的,myswl数据(静态代码块来加载驱动)</p>
</li>
<li><p>final可以修饰<br> 类，成员变量，成员方法，局部变量(基本类型，引用类型)<br> 1.修饰类(太监类)，不能被继承<br> 2.final修饰成员变量: </p>
<pre><code> 2.1必须在创建对象之前有却确定的值
 2.3只能赋值一次
</code></pre>
<p> 3.修饰方法:</p>
<pre><code> 不能被子类重写
</code></pre>
<p> 4.修饰基本类型局部变量</p>
<pre><code> 被final修饰的基本类型局部变量  只能赋值一次
</code></pre>
<p> 5.修饰引用类型局部变量</p>
<pre><code> 被final修饰的引用类型局部变量  只能赋值一次
 但是引用类型所指向的对象中内容是可以改变的
</code></pre>
</li>
<li><p>匿名内部类：是一种特殊的语法，用来快速创建抽象类的子类对象</p>
<pre><code>         用来快速创建 接口的实现类对象
</code></pre>
<p> AbstractAnimal an1 = new AbstractAnimal(){</p>
<pre><code> 重写
</code></pre>
<p> }<br> 多态</p>
</li>
<li><p>引用数据类型<br>a.类作为方法的参数或者返回值(我们需要传递或返回的是该类的对象)<br>b.抽象类作为方法的参数和返回值  (和9结合起来)我们需要传递或返回的是该抽象类的子类的对象<br>c.接口作为方法的参数和返回值   (我们需要传递或返回的是该接口的实现类的对象)</p>
</li>
<li><p>链式编程</p>
</li>
<li><p>权限修饰符<br>如果一个成员只想在本类中使用 用private修饰<br>如果一个成员想在本类和本包的其它类中使用 不写 default<br>如果一个成员想在本类，本包，其他包的子类中使用 用protected修饰<br>如果一个成员想在所有类中使用 用public修饰</p>
</li>
<li><p>Object类：<br>类Object是类层次结构的根类<br>所有类都必须直接或者间接的继承object</p>
<ol>
<li>boolean equals(Object obj);<br>p1.equals(p2);<br>//比较两个对象是否相等,在Object类中定义equals方法比较是 两个对象的地址<br>在String类中 重写了object父类中的equals方法，<br> 本来在object类中比较的是两个对象的地址<br> 在String重写后变成比较两个字符串的内容</li>
</ol>
<p>我们程序员 通常自定义一个类 也会重写equals</p>
<ol start="2">
<li>toString(); //返回该对象的字符串表示<br> Object类中的默认的返回值：包名.类名@地址<br> 实际开发中toString的使用，重写toString 返回对象中的成员变量</li>
</ol>
</li>
<li><p>异常:是java代码编译或者运行过程中<br>异常的继承体系:<br>Throwable(异常和错误的超类):可以抛出去的东西</p>
<pre><code>--Exception:异常(普通问题) 
--编译时异常:
  指的是Exception 以及Exception子类  (除了RuntimeException)
--运行时异常:
  RuntimeException以及其子类
--Error:错误(严重问题) 
比如:OutOfMemoryError:超出内存错误
如果程序出现了错误，只能改代码
</code></pre>
<p>创建异常对象，对异常的基本操作：<br>1.抛出异常 2.处理异常(捕获异常，将异常获取，使用try/catch做分支处理)<br>JVM默认处理异常的方式:(中断处理)<br>处理异常的方式：<br>1.不处理</p>
<pre><code>public 返回值类型 方法名(参数)throws xxxException&#123;

&#125;
</code></pre>
<p>2.捕获处理</p>
<pre><code>try&#123;
    可能出现的异常的代码
&#125;catch(Exception e)&#123;
    //处理异常
&#125;finally&#123;
    //写上必须要执行的代码
    //释放资源的代码
&#125;
</code></pre>
<p>3.其他的处理方式</p>
<pre><code>多个异常分别处理
多个个异常一次捕获多次处理
多个异常一次捕获一次处理
</code></pre>
<p>父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理。<br>打印异常信息:printStackTrace<br>1.RuntimeException<br>2.ClassCastException   类型转换异常(向下转型的时候)<br>3.ArrayIndexOutOfBoundsException  数组下标越界<br>4.StringIndexOutOfBoundsException  字符串下标越界<br>自定义异常类：<br>1.创建一个类，这个类必须用Exception结尾<br>2.必须继承Exception 或者  RumtimeException<br>3.自定义的异常 至少有两个构造</p>
<pre><code>a.空参数构造
b.带有String类型参数构造
</code></pre>
</li>
<li><p>Object类:是所有类的根类<br>boolean equals(Object obj)<br>a.Object类中equals方法,比较是两个对象的地址，就是==号的作用<br>b.重写  比较两个字符串的内容   比较两个对象的成员变量的值<br>String toString();//返回该对象的字符串表示   hashCode()返回该对象的数字表示</p>
</li>
<li><p>什么叫设计模式？<br>把解决问题的方案 总结出一个套路</p>
</li>
<li><p>代理设计模式<br>  1.1静态代理设计模式<br>  1.2动态代理设计模式</p>
</li>
<li><p>date类:日期类</p>
<pre><code>表示特定的瞬间，精确到毫秒
</code></pre>
<p>public Date(); //无参构造<br>public Date(long time);<br>1.DateFormat是一个抽象类 我们不能用它<br>2.我们使用它的一个子类：SimpleDateFormat<br>SimpleDateFormat:简单的日期格式化类<br>1.构造</p>
<pre><code>public SimpleDateFormat(String pattern);//以指定的模式 创建一个日期格式化对象
</code></pre>
<p>2.成员方法</p>
<pre><code>public String format(Date d);//格式化一个日期对象，返回格式化后的一个字符串
public Date parse(String s);//把一个字符串形式的日期，解析成Date对象
</code></pre>
</li>
<li><p>Calender类<br>获取Calendar的子类对象<br>获取Calender对象的某个字段 (get)</p>
</li>
<li><p>System类<br>它不能被实例化，因为构造方法私有化了<br>而且System类中的方法都是静态的，通过类名就可以直接访问<br>System.exit(0); //退出JVM<br>public static void gc(); //运行java的垃圾回收器(并不是马上运行)<br>public static String getProperty(String ProertyName);//获取某一个属性的值<br>public static long currentTimeMillis();//获取当前系统的毫秒值</p>
</li>
<li><p>String(不可变)  StringBuilder(可变)<br>//当出现大量的字符串拼接运算 时 用StringBuilder</p>
</li>
<li><p>基本数据类型 对应的引用类型<br>int Integer<br>拆箱：包装类型—&gt;基本类型<br>装箱：基本类型—&gt;包装类型</p>
</li>
<li><p>正则表达式：</p>
</li>
<li></li>
<li><p>javac 生成编译文件</p>
</li>
<li><p>java 执行类文件，出错原因java程序运行class文件,对于有包名的类,java把包名当成文件夹处理.”包名+类名”相当于”文件夹目录+类名”来寻找类。</p>
</li>
<li><p>b = a++ a先赋值，再自增。  </p>
</li>
<li><p>mysql Orcale DB2(银行系统)  SQLite(手机端) SQLServer SyBase(建模工具PowerDesigner) </p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(2)</title>
    <url>/2020/01/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%91%E6%8C%87offer(2)/</url>
    <content><![CDATA[<hr>
<ul>
<li>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。  </li>
</ul>
<hr>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    	String str1 = str.toString();</span><br><span class="line">        if(str1.equals(&quot;&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            return(str1);</span><br><span class="line">        &#125;</span><br><span class="line">        char [] strArray = str1.toCharArray();</span><br><span class="line">        int lengthSpace = 0;</span><br><span class="line">        for(int i = 0;i&lt;strArray.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(strArray[i]==&#x27; &#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                lengthSpace++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int newStrLength = strArray.length + lengthSpace*2;</span><br><span class="line">        char [] newstrArray = new char[newStrLength];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for(int i = 0;i&lt;strArray.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(strArray[i]!=&#x27; &#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                newstrArray[i+count*2] = strArray[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                newstrArray[i+2*count]=&#x27;%&#x27;;</span><br><span class="line">                newstrArray[i+2*count+1]=&#x27;2&#x27;;</span><br><span class="line">                newstrArray[i+2*count+2]=&#x27;0&#x27;;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        return new String(newstrArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">return str.toString().replaceAll(&quot;\\s&quot;, &quot;%20&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题解：如果建新数组的话，从后往前还是从前往后都是一样的。???</p>
<ol>
<li>charAt(),deleteCharAt()   <blockquote>
<p>s1.charAt(3);<br> s1.deleteCharAt(3); </p>
</blockquote>
</li>
<li>setCharAt();<br>替换所引出的char值<blockquote>
<p>str.setCharAt(indexnew, ‘0’);</p>
</blockquote>
</li>
<li>append();  <blockquote>
<p>StringBuffer s1 = new StringBuffer().append(“bbb”);<br> s1.append(“aaa”);<br> System.out.println(s1.toString());</p>
</blockquote>
</li>
<li>replace两种用法：  <blockquote>
<p>replace(int start，int end, String str)<br>replace(char oldchar, char newchar)</p>
</blockquote>
</li>
<li>toString()  toCharArray()  <blockquote>
<p>StringBuffer s1 = new StringBuffer();<br>s1.toString();<br>String s2 = new String();<br>s2.toCharArray();</p>
</blockquote>
</li>
<li>delete(); insert(); indexOf(); lastIndexOf(); reverse(); length();<br>indexOf()返回指定字符串的开始字符索引位置，还可以从某个字符索引位置开始向后匹配，没有找到匹配的就会返回-1<br>lastIndexOf()是从后往前匹配，也支持从指定索引开始从后往前去匹配<blockquote>
<p>s1.delete(2,4);<br>s1.insert(2,”cc”);<br>System.out.println(s1.indexOf(“ba”));<br>System.out.println(s1.indexOf(“ba”,2));<br>System.out.println(s1.reverse());<br>System.out.println(s1.length());</p>
</blockquote>
</li>
<li>String,StringBuffer,StringBuilder三者的使用方法和区别<br>String适用于少量的字符串操作的情况<br>StringBuilder适用于单线程下在字符缓冲区进行大量操作的情况<br>StringBuffer适用多线程下在字符缓冲区进行大量操作的情况</li>
</ol>
<ol start="6">
<li>一.java数据类型</li>
<li>基本数据类型<br>byte(1) boolean(1) short(2) char(2) int(4) float(4) long(8)double (8)</li>
<li>引用数据类型<br>string,数组，集合ArrayList,Scanner,Random,自定义类型</li>
<li>引用类型String中的方法<br>第一组：判断方法<br>boolean equals(String str);  //比较两个字符串是否相等<br>boolean equalsIgnoreCase(String str);  //比较两个内容是否相等 （忽略大小写）<br>boolean startsWith(String subStr); //判断某个字符串是否以指定的子串开头<br>boolean endsWith(String subStr); //判断某个字符串是否以指定的子串结尾<br>第二组：获取方法<br>int length();//获取字符串中字符个数<br>char charAt(int index); //获取字符串中某一个字符<br>String substring(int startIndex);//从指定下标开始截取字符串，直到字符串结尾<br>substring(int startIndex,int endIndex); //包括开头不包括结尾？<br>int indexof(String subStr); //获取子串第一次出现的下标<br>第三组：转换方法<br>String toLowerCase(); //转成小写串<br>String toUpperCase);  //转成大写串<br>Char[] toCharArray(); //变成字符数组<br>第四组：其他方法<br>String trim();//去掉字符串两端的空格<br>String[] split(String str); //切割字符串<br>三：读写文件<br>输出流：数据从java程序 到  文件中<br>FilWriter：文件的字符输出流，写数据  （一个字符，一个字符串，一个字符数组）<br>  write(int ch);// 写一个字符<br>  write(char[] chs); //写一个字符数组<br>  write(String s);// 写一个字符串<br>  write(char[] chs,int startInex,int len);// 写一个字符数组的一部分<br>  write(String s,int startInex,int len); //写一个字符串的一部分<br>输入流：数据从文件  到  java程序中<br>FileReader:文件的字符输入流,读数据（一个字符，一个字符数组）<br>   int read();//读取一个字符  ASCII<br>   int read(char[] chs); //一次读取一个字符数组，返回值是读取的字符的个数<br>文件的路径分为两种：</li>
<li>相对路径：<pre><code>  相对于当前项目而言的
</code></pre>
</li>
<li>绝对路径：<pre><code>  以盘符开头
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
